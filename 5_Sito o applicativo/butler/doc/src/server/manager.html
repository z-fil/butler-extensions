<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.server.manager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.server.manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import threading
import base64
import os
import hashlib
from os.path import abspath, isfile, join, basename, exists
from time import sleep, time
from json.decoder import JSONDecodeError
import sys
import copy
import webbrowser

sys.path.append(abspath(join(sys.path[0], &#39;..&#39;)))

from common.logger import Logger
from common import log
from common.notificationBuilder import NotificationBuilder
from common.configParser import ConfigParser
from common.argsParser import ArgsParser
from server.controlCenterGUI import ControlCenterGUI
from server.controlCenterAPI import ControlCenterAPI
from server.butlerAPI import ButlerAPI
from server.ipParser import IPParser
from server.butler import Butler
from server.dbHelper import DbHelper

class Manager:
        &#34;&#34;&#34;
        Questa classe gestisce la parte server del programma Butler.
        Gestisce la connessione full-duplex dei Butlers e il centro di controllo web.
        &#34;&#34;&#34;

        TIMER = 1
        STANDARD_MODEL_MAC = &#39;&#39;
        butlers = {}
        interactions = {}

        collMap = {&#39;connection&#39;: &#39;model&#39;, &#39;phase&#39;: &#39;phase&#39;, &#39;module&#39;: &#39;modules&#39;}

        def start(self):
                &#34;&#34;&#34;
                Punto d&#39;entrata del programma.
                - Ascolta le richieste da qualunque Butlers
                - Mette a disposizione l&#39;interfaccia REST di controllo
                - Avvia l&#39;interfaccia web di gestione
                - Legge i buffer di notifiche in sospeso dal database
                &#34;&#34;&#34;
                params = [
                        {&#39;short&#39;: &#39;c&#39;, &#39;full&#39;: &#39;config&#39;, &#39;args&#39;: True, &#39;default&#39;: &#39;.&#39;,
                         &#39;help&#39;: &#39;Usa il file di configurazione dal percorso specificato.\nSe non è dato nessun percorso, viene preso quello di avvio del programma.&#39;},
                        {&#39;short&#39;: &#39;g&#39;, &#39;full&#39;: &#39;gui&#39;, &#39;args&#39;: True, &#39;default&#39;: &#39;&#39;, &#39;help&#39;:
                         &#39;&#39;&#39;Avvia l\&#39;interfaccia web del centro di controllo solo con alcune sezioni.
I parametri possibili sono:
\tmanager\t  Creazione e gestione delle notifiche
\tpreview\t  Anteprima della notifica (funzione sperimentale)
\tlist\t  Informazioni e gestione dei Butlers collegati&#39;&#39;&#39;},
                        {&#39;short&#39;: &#39;n&#39;, &#39;full&#39;: &#39;no_gui&#39;, &#39;args&#39;: False, &#39;default&#39;: &#39;&#39;, &#39;help&#39;:
                         &#39;&#39;&#39;Non avvia l&#39;interfaccia web.
Il server rimane raggiungibile attraverso richieste REST.&#39;&#39;&#39;},
                        {&#39;short&#39;: &#39;p&#39;, &#39;full&#39;: &#39;passive&#39;, &#39;args&#39;: False, &#39;default&#39;: &#39;&#39;,
                         &#39;help&#39;: &#39;Ignora il buffer delle notifiche.&#39;}
                ]
                argsParser = ArgsParser(params)
                args = argsParser.parse()
                try:
                        self.configs = ConfigParser().load_configs(args[&#39;config&#39;])
                except FileNotFoundError as e:
                        log.critical(
                                &#39;Impossibile leggere il file di configurazione:\n{}&#39;.format(e.__str__()))
                        return
                except JSONDecodeError as e:
                        log.critical(
                                &#39;Errore nella decodifica del file di configurazione:\n{}&#39;.format(e.__str__()))
                        return

                Logger().start(**self.configs[&#39;logging&#39;])
                self.ipParser = IPParser()
                self.expireTime = self.configs[&#39;expireTime&#39;]
                self.protocol = self.configs[&#39;protocol&#39;]
                self.serverConf = self.configs[&#39;server&#39;]
                self.controlConf = self.configs[&#39;controlCenter&#39;]
                self.guiConf = self.configs[&#39;gui&#39;]
                self.testNotifData = &#39;&#39;

                self.addr = &#39;{}://{}:{}&#39;.format(self.protocol,
                                                                                self.serverConf[&#39;ip&#39;], self.serverConf[&#39;port&#39;])
                self.id = self.serverConf[&#39;id&#39;]
                log.info(&#39;Avvio del server su {}&#39;.format(self.addr))

                # avvio dell&#39;ascoltatore dei Butlers
                butlerCallbacks = {&#39;add_butler&#39;: self.add_butler,
                                         &#39;disconnect&#39;: self.disconnect_client,
                                         &#39;interacted&#39;: self.interacted, &#39;update_db_details&#39;: self.update_db_details,
                                         &#39;butler_exists&#39;: self.butler_exists}

                self.butlerApi = ButlerAPI(self.serverConf[&#39;ip&#39;], self.serverConf[&#39;port&#39;],
                                                         self.expireTime, self.configs[&#39;ssl&#39;], butlerCallbacks,
                                                         )
                threading.Thread(target=self.butlerApi.start_api, daemon=True).start()

                # imposta e avvia l&#39;API del centro di controllo
                controlCenterAddr = &#39;{}://{}:{}&#39;.format(
                        self.protocol, self.controlConf[&#39;ip&#39;], self.controlConf[&#39;port&#39;])
                self.dbHelper = DbHelper()
                self.dbHelper.login(**self.configs[&#34;database&#34;])

                controlCallbacks = {&#39;send_notif&#39;: self.send_notif, &#39;check_butlers&#39;: self.check_butlers,
                                          &#39;can_disconnect&#39;: self.can_disconnect, &#39;force_disconnect&#39;: self.force_disconnect,
                                          &#39;get_files&#39;: self.get_files_list, &#39;revoke&#39;: self.revoke,
                                          &#39;validate_credentials&#39;: self.validate_credentials,
                                          &#39;test_notif&#39;: self.test_notif,
                                          &#39;get_butler_details&#39;: self.get_butler_details,
                                          &#39;set_butler_details&#39;: self.set_butler_details,
                                          &#39;edit_butler&#39;: self.edit_butler, &#39;apply_standard_model&#39;: self.apply_standard_model}

                sections = args[&#39;gui&#39;].split(
                        &#39;,&#39;) if args[&#39;gui&#39;] != &#39;&#39; else self.guiConf[&#39;sections&#39;]

                self.controlCenterApi = ControlCenterAPI(self.controlConf[&#39;ip&#39;], self.controlConf[&#39;port&#39;],
                                                                                   self.configs[&#39;expireTime&#39;], self.configs[&#39;ssl&#39;], controlCallbacks,
                                                                                   self.dbHelper, self.configs[&#39;imagesPath&#39;], self.controlConf[&#39;previewPort&#39;],
                                                                                   &#39;{}://{}:{}&#39;.format(self.protocol, self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;]), sections)
                threading.Thread(target=self.controlCenterApi.start_api, daemon=True).start()

                # avvio del controllo del buffer
                if self.configs[&#39;bufferTimer&#39;] &gt;= 1 and not args[&#39;passive&#39;]:
                        threading.Thread(target=self.check_buffer, args=[
                                self.configs[&#39;bufferTimer&#39;]], daemon=True).start()

                # prepara l&#39;interfaccia grafica del server
                guiAddr = &#39;{}://{}:{}&#39;.format(
                        self.protocol, self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;])

                self.controlCenterGui = ControlCenterGUI(self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;],
                                                                                   controlCenterAddr, self.configs[&#39;ssl&#39;], self.configs[&#39;gui&#39;][&#39;templatesPath&#39;], self.configs[&#39;gui&#39;][&#39;resPath&#39;])
                threading.Thread(target=self.controlCenterGui.start_api, daemon=True).start()

                # se necessario, apre una finestra del browser per la GUI
                if not args[&#39;no_gui&#39;]:
                        webbrowser.open(guiAddr, new=2, autoraise=False)

                notifBuilder = NotificationBuilder(
                        logoPath=self.configs[&#39;logoPath&#39;], testing=True)

                try:
                        while True:
                                if self.testNotifData != &#39;&#39;:
                                        log.warning(&#39;Test reale della notifica &#34;{}&#34;&#39;.format(
                                                self.testNotifData[&#39;name&#39;]))
                                        notifBuilder.interrupt = False
                                        notifBuilder.show_window(self.testNotifData)
                                        self.testNotifData = &#39;&#39;
                                sleep(self.TIMER)

                except KeyboardInterrupt:
                        sys.exit()

        def check_buffer(self, timer):
                &#34;&#34;&#34;
                Controlla periodicamente il buffer delle notifiche in sospeso,
                se il parametro è maggiore o uguale a 1 secondo.
                
                :param timer (int): il tempo di attesa tra i controlli (in secondi).
                &#34;&#34;&#34;
                log.info(&#39;Inizio del controllo del buffer&#39;)
                try:
                        while True:
                                for b in self.dbHelper.get_buffer():
                                        log.info(&#39;Tentativo di invio della notifica &#34;{}&#34; dal buffer&#39;.format(
                                                b[&#39;notification&#39;]))
                                        for addr in self.send_notif(b[&#39;notification&#39;], b[&#39;recipients&#39;], b[&#39;excluded&#39;]):
                                                if self.butlers[addr].ip not in b[&#39;excluded&#39;]:
                                                        b[&#39;excluded&#39;].append(self.butlers[addr].ip)
                                                log.info(&#39;Notifica &#34;{}&#34; inviata a {}&#39;.format(b[&#39;notification&#39;], addr))
                                        self.dbHelper.update_buffer(b)
                                        sleep(1)
                                sleep(timer)
                except KeyboardInterrupt:
                        sys.exit()

        def send_notif(self, name, recipients, excluded=[]):
                &#34;&#34;&#34;
                Generatore per inviare notifiche e ritornare gli indirizzi di chi ha
                ricevuto i messaggi.
                
                :param name (str): il nome della notifica.
                :param recipients (list): la lista degli indirizzi dei destinatari.
                :param excluded (list): la lista degli indirizzi da non considerare.
                        Default: [].
                
                :yield: gli indirizzi di chi ha risposto all&#39;invio della notifica.
                &#34;&#34;&#34;
                # la wildcard * viene sostituita da tutti i destinatari
                if recipients == [&#39;*&#39;]:
                        recipients = [self.butlers[addr].ip for addr in self.butlers]
                # i destinatari vengono rimossi se presenti tra quelli esclusi
                recipients = [addr for addr in recipients if addr not in excluded]

                log.warning(&#39;Invio di &#34;{}&#34; a {} Butler&#39;.format(name, len(recipients)))
                for addr in self.butlers:
                        if self.butlers[addr].ip not in excluded and self.ipParser.include(recipients, self.butlers[addr].ip):
                                data = self.parse_notif_data(self.dbHelper.get_notif_data(name))
                                received = self.butlers[addr].send({&#39;notifData&#39;: data})
                                if received:
                                        log.info(&#39;{} ha ricevuto &#34;{}&#34;&#39;.format(addr, name))
                                        yield addr

        def validate_credentials(self, user, password):
                &#34;&#34;&#34;
                Controlla che le credenziali passate corrispondano a quelle memorizzate
                nel file di configurazione.
                La pasword è salvata come SHA265.
                
                :param user (str): il nome utente dell&#39;amministratore.
                :param password (str): la password dell&#39;amministratore.
                
                :return: True se le credenziali corrispondono.
                &#34;&#34;&#34;
                return user == self.configs[&#39;username&#39;] and hashlib.sha256(password.lower().encode(&#34;utf&#34;)).hexdigest() == self.configs[&#39;password&#39;].lower()

        def add_butler(self, mac, addr, user):
                &#34;&#34;&#34;
                Crea un oggetto Butler e, se è possibile stabilire una connessione,
                lo aggiunge alla lista. 
                
                :param mac (str): l&#39;indirizzo MAC del computer.
                :param addr (str): l&#39;indirizzo IPv4 del Butler.
                :param user (str): il nome dell&#39;utente.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        return self.butlers[addr].get_status()

                b = Butler(self.protocol, mac, addr, user, self.addr, self.id)
                if b.authenticate():
                        log.info(&#39;Autenticazione con {} riuscita, aggiunto alla lista.&#39;.format(addr))
                        # la deepcopy permette di passare una versione dell&#39;oggetto, non un riferimento
                        self.butlers[addr] = copy.deepcopy(b)
                        threading.Thread(target=self.set_butler_details, args=[addr]).start()
                        return True
                else:
                        log.warning(&#39;Non è possibile stabilire la comunicazione con {}&#39;.format(addr))
                        del b
                        return False

        def disconnect_client(self, addr):
                &#34;&#34;&#34;
                Disconnette un client se ne ha il permesso.

                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da disconnettere.

                :return: True è stato possibile rimuovere il Butler dalla lista,
                        False in caso sia ancora connesso.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        if self.butlers[addr].canDisconnect:
                                log.warning(&#39;Disconnessione di {} avvenuta&#39;.format(addr))
                                self.butlers[addr].disconnect()
                                # se non c&#39;è la chiave, ritorna &#39;&#39;
                                self.butlers.pop(addr, &#39;&#39;)
                        else:
                                return False
                return True

        def interacted(self, addr, notifName):
                &#34;&#34;&#34;
                Aggiunge il Butler alla lista di host che hanno interagito con una certa notifica.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                :param notifName (str): il nome della notifica.
                &#34;&#34;&#34;
                if addr != &#39;&#39; and len(self.butlers) &gt; 0:
                        self.interactions[notifName].append(self.butlers[addr].address)

        def check_butlers(self, addr=&#39;&#39;):
                &#34;&#34;&#34;
                Verifica lo stato dei Butlers.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da controllare.
                        Default: &#39;&#39;.
                
                :return: la lista con le informazioni dei Butler ancora connessi.
                        È sempre ritornato almeno l&#39;indirizzo, ma se questo non è allegato
                        ad altri dati significa che il Butler non è attivo: in questo modo
                        è possibile verificare chi è andato offline rispetto all&#39;ultimo controllo.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        if self.butlers[addr].get_status():
                                return [{&#39;addr&#39;: addr, &#39;user&#39;: self.butlers[addr].user,
                                                        &#39;mac&#39;: self.butlers[addr].mac,
                                                        &#39;canDisconnect&#39;: self.butlers[addr].canDisconnect}]
                        else:
                                del self.butlers[addr]
                elif addr == &#39;&#39;:
                        # se l&#39;indirizzo è vuoto, vengono verificati tutti i Butlers
                        butlersInfo = []
                        try:
                                for addr in self.butlers:
                                        if self.butlers[addr].get_status():
                                                butlersInfo.append({&#39;addr&#39;: addr,
                                                                                        &#39;user&#39;: self.butlers[addr].user,
                                                                                        &#39;mac&#39;: self.butlers[addr].mac,
                                                                                        &#39;canDisconnect&#39;: self.butlers[addr].canDisconnect})
                                        else:
                                                butlersInfo.append({&#39;addr&#39;: addr})
                        except Exception as e:
                                log.warning(
                                        &#39;Errore nella verifica dello stato dei Butlers: {}&#39;.format(e.__str__()))
                        for b in butlersInfo:
                                if &#39;user&#39; not in b and b[&#39;addr&#39;] in self.butlers:
                                        del self.butlers[b[&#39;addr&#39;]]
                        return butlersInfo

                return {&#39;addr&#39;: addr}

        def can_disconnect(self, addr, permission):
                &#34;&#34;&#34;
                Imposta il permesso di disconnessione di un client.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                :param permission (bool): il permesso di disconnessione.
                &#34;&#34;&#34;
                log.info(&#39;Cambio del permesso di disconnessione a {} in {}&#39;.format(addr, permission))
                if self.addr_exists(addr):
                        self.butlers[addr].canDisconnect = permission

        def force_disconnect(self, addr):
                &#34;&#34;&#34;
                Forza la disconnessione di un Butler impostando il permesso e inviando la richiesta.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                &#34;&#34;&#34;
                log.info(&#39;Richiesta di disconnessione a {}&#39;.format(addr))
                self.can_disconnect(addr, True)
                self.disconnect_client(addr)

        def revoke(self, name):
                &#34;&#34;&#34;
                Revoca una notifica da tutti i Butlers, chiedendo la sua chiusura.
                
                :param name (str): il nome della notifica da chiudere.
                &#34;&#34;&#34;
                for addr in self.butlers:
                        self.butlers[addr].revoke(name)

        def test_notif(self, data):
                &#34;&#34;&#34;
                Autoinvia una notifica per testarne unicamente lo stile.
                
                :param data (dict): i dati della notifica da mostrare.
                &#34;&#34;&#34;
                self.testNotifData = self.parse_notif_data(data)

        def get_files_list(self, pathKey):
                &#34;&#34;&#34;
                Legge un percorso apposito specificato nel file di configurazione e ritorna
                la lista dei file presenti.
                È usato per ricavare la lista di immagini e di scripts.
                
                :param pathKey (str): la chiave della configurazione corrispondente al
                        tipo di file richiesto.
                
                :return: la lista dei nomi dei file.
                &#34;&#34;&#34;

                return [f for f in os.listdir(abspath(join(sys.path[0], self.configs[pathKey]))) if isfile(join(sys.path[0], self.configs[pathKey], f))]

        def addr_exists(self, addr):
                &#34;&#34;&#34;
                Verifica che si possa accedere ai dati del Butler ricercandolo nella lista
                in base al suo indirizzo.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                
                :return: True se esistono dati associati all&#39;indirizzo richiesto, False
                        in tutti gli altri casi.
                &#34;&#34;&#34;
                return len(self.butlers) &gt; 0 and addr != [] and addr != {} and addr in self.butlers

        def parse_notif_data(self, data):
                &#34;&#34;&#34;
                Modifica i dati della notifica sostituendo i percorsi relativi al server
                con i dati base64 del file in quel percorso. Se non esiste il file,
                il dato viene comunque passato come percorso assumento si tratti di
                una cartella presente localmente nel client.
                
                :param data (dict): i dati della notifica da modificare.
                
                :return: il dizionario dei dati pronto all&#39;uso.
                &#34;&#34;&#34;
                if &#39;style&#39; in data and data[&#39;style&#39;][&#39;image&#39;] != &#39;&#39;:
                        data[&#39;style&#39;][&#39;image&#39;] = self.get_file_data(
                                self.configs[&#39;imagesPath&#39;], data[&#39;style&#39;][&#39;image&#39;])
                if data[&#39;script&#39;][&#39;program&#39;] != &#39;&#39;:
                        data[&#39;script&#39;][&#39;program&#39;] += &#39; &#39;+basename(data[&#39;script&#39;][&#39;command&#39;])
                        data[&#39;script&#39;][&#39;command&#39;] = self.get_file_data(
                                self.configs[&#39;scriptsPath&#39;], data[&#39;script&#39;][&#39;command&#39;])
                else:
                        log.info(&#39;Script vuoto&#39;)

                return data

        def get_file_data(self, basePath, path):
                &#34;&#34;&#34;
                Tenta di leggere i dati del file nel percorso specificato.
                
                :param basePath (str): la base del percorso nel quale cercare.
                :param path (str): il percorso che specifica almeno il nome del file.
                
                :return: i dati base64 del file se esiste, altrimenti il suo percorso.
                &#34;&#34;&#34;
                try:
                        fullPath = abspath(join(sys.path[0], basePath, path))
                        if exists(path):
                                pass
                        elif exists(fullPath):
                                path = fullPath
                        with open(path, &#34;r+b&#34;) as file:
                                log.warning(
                                        &#39;È stato inviato il file in &#34;{}&#34; insieme ad una notifica&#39;.format(path))
                                return base64.b64encode(file.read()).decode()
                except Exception as e:
                        log.warning(
                                &#39;Il file verrà inviato come percorso a causa del seguente errore: {}&#39;.format(e.__str__()))
                log.warning(
                        &#39;È stato inviato il percorso &#34;{}&#34; insieme ad una notifica (non è stato trovato localmente)&#39;.format(path))
                return path

        &#34;&#34;&#34;
        #####################################
        Funzioni aggiuntive butler-extensions
        #####################################
        &#34;&#34;&#34;

        def edit_butler(self, addr, data, endpoint):
                &#34;&#34;&#34;
                Permette di modificare un parametro di un Butler.

                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da modificare.
                :param data (str): i dati da modificare.
                :param endpoint (str): l&#39;endpoint del Butler.
                &#34;&#34;&#34;
                if self.addr_exists(addr) and endpoint != &#39;&#39; and data != &#39;&#39;:
                        data[&#39;mac&#39;] = self.butlers[addr].mac
                        self.dbHelper.upsert_details(data)
                        self.butlers[addr].edit(data, endpoint)

        def apply_standard_model(self, addr):
                &#34;&#34;&#34;
                Invia i dati del modello standard ad un Butler.
                L&#39;operazione non viene effettuata completamente dal gestore del database,
                poichè alcuni dati devono poi essere inviati al client.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler al quale inviare i dati.

                :return: il numero di connessioni applicate.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        # query al modello standard con MAC &#34;&#34;
                        standardModel = self.dbHelper.get_computer_data(self.STANDARD_MODEL_MAC)
                        if &#39;model&#39; in standardModel:
                                standardModel[&#39;mac&#39;] = self.butlers[addr].mac
                                self.dbHelper.upsert_details(standardModel)
                                self.butlers[addr].update_model(standardModel[&#39;model&#39;])
                                return len(standardModel[&#39;model&#39;])
                return 0

        def get_butler_details(self, addr):
                &#34;&#34;&#34;
                Richiede i dettagli al Butler e gestisce i valori vuoti che
                il client ritorna se non ha certi moduli attivi.

                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler al quale richiedere i dati.

                :return: i dati ricevuti.
                &#34;&#34;&#34;
                if self.addr_exists(addr):

                        details = self.butlers[addr].get_details()
                        # se non ci sono dettagli, verifica che l&#39;host sia ancora connesso
                        if details == {}:
                                self.check_butlers()
                                return {}

                        self.set_butler_details(addr, details)
                        details = self.dbHelper.get_computer_data(self.butlers[addr].mac)

                        if &#39;inventory&#39; not in details:
                                details[&#39;inventory&#39;] = {}

                        if &#39;model&#39; not in details:
                                details[&#39;model&#39;] = {}
                                details[&#39;phase&#39;] = &#39;&#39;

                        # modules non deve essere gestito.
                        # Se manca, altre classi si accorgeranno dell&#39;errore

                        details[&#39;mac&#39;] = self.butlers[addr].mac
                        return details
                return {}

        def set_butler_details(self, addr, butlerDetails={}):
                &#34;&#34;&#34;
                Sincronizza le informazioni tra database e client
                garantendo la loro consistenza.

                :param addr (str): l&#39;indirizzo e la porta del quale verificare i dati.
                :param butlerDetails (dict): i dati del Butler, se già richiesti.
                        Default: {}.
                &#34;&#34;&#34;
                # i dettagli vengono presi prima di controllare se l&#39;host esiste
                # dato che questo potrebbe essere rimosso durante la chiamata
                if butlerDetails == {}:
                        butlerDetails = self.get_butler_details(addr)
                if self.addr_exists(addr) and butlerDetails != {}:
                        # i dati del modello del database hanno la precedenza su quelli del Butler
                        dbDetails = self.dbHelper.get_computer_data(self.butlers[addr].mac)

                        sameAttr = []
                        for attr in butlerDetails:
                                # verifica che l&#39;attributo esista in entrambi gli array
                                # e che i valori corrispondano, oppure che abbiamo dimensione uguale
                                if attr in dbDetails and (butlerDetails[attr] == dbDetails[attr] or isinstance(butlerDetails[attr], list) and len(butlerDetails[attr]) == len(dbDetails[attr])):
                                        sameAttr.append(attr)
                        for attr in sameAttr:
                                del butlerDetails[attr]
                                del dbDetails[attr]

                        # i dati dell&#39;inventario presi dal Butler hanno la precedenza su quelli del database
                        if &#39;inventory&#39; in butlerDetails:
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;inventory&#39;: butlerDetails[&#39;inventory&#39;]})

                        if &#39;model&#39; in dbDetails:
                                if &#39;model&#39; in butlerDetails and len(butlerDetails[&#39;model&#39;]) &gt; len(dbDetails[&#39;model&#39;]):
                                        self.dbHelper.upsert_details(
                                                {&#39;mac&#39;: self.butlers[addr].mac, &#39;model&#39;: butlerDetails[&#39;model&#39;]})

                                self.butlers[addr].update_model(dbDetails[&#39;model&#39;])
                                if &#39;phase&#39; in dbDetails:
                                        self.butlers[addr].edit({&#39;phase&#39;: dbDetails[&#39;phase&#39;]}, &#39;/phase&#39;)
                                        
                        # solo se il database non ha informazioni a riguardo vengono prese
                        # direttamente quelle del Butler
                        elif &#39;model&#39; in butlerDetails:
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;model&#39;: butlerDetails[&#39;model&#39;]})
                                # se il database ha tutti i dati, ma manda il modello
                                # è probabile che il client non invii anche la fase
                                if &#39;phase&#39; in butlerDetails:
                                        self.dbHelper.upsert_details(
                                                {&#39;mac&#39;: self.butlers[addr].mac, &#39;phase&#39;: butlerDetails[&#39;phase&#39;]})

                        # anche i moduli hanno la precedenza se presenti nel database
                        if &#39;modules&#39; in dbDetails:
                                self.butlers[addr].edit({&#39;modules&#39;: dbDetails[&#39;modules&#39;]}, &#39;/module&#39;)
                        elif &#39;modules&#39; in butlerDetails:
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;modules&#39;: butlerDetails[&#39;modules&#39;]})

        def update_db_details(self, details):
                &#34;&#34;&#34;
                Aggiorna le informazioni ricevute dal Butler nel database.

                :param details (dict): i dati da aggiornare.
                &#34;&#34;&#34;
                self.dbHelper.upsert_details(details)

        def butler_exists(self, addr):
                &#34;&#34;&#34;
                Controlla se l&#39;indirizzo passato fa parte dell&#39;array di Butlers
                
                :param addr (str): l&#39;indirizzo identificativo.
                
                :return True se è presente, altrimenti False.
                &#34;&#34;&#34;
                return addr in self.butlers

        &#34;&#34;&#34;
        ##########################################
        Fine funzioni aggiuntive butler-extensions
        ##########################################
        &#34;&#34;&#34;


if __name__ == &#34;__main__&#34;:
        Manager().start()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.server.manager.Manager"><code class="flex name class">
<span>class <span class="ident">Manager</span></span>
</code></dt>
<dd>
<div class="desc"><p>Questa classe gestisce la parte server del programma Butler.
Gestisce la connessione full-duplex dei Butlers e il centro di controllo web.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Manager:
        &#34;&#34;&#34;
        Questa classe gestisce la parte server del programma Butler.
        Gestisce la connessione full-duplex dei Butlers e il centro di controllo web.
        &#34;&#34;&#34;

        TIMER = 1
        STANDARD_MODEL_MAC = &#39;&#39;
        butlers = {}
        interactions = {}

        collMap = {&#39;connection&#39;: &#39;model&#39;, &#39;phase&#39;: &#39;phase&#39;, &#39;module&#39;: &#39;modules&#39;}

        def start(self):
                &#34;&#34;&#34;
                Punto d&#39;entrata del programma.
                - Ascolta le richieste da qualunque Butlers
                - Mette a disposizione l&#39;interfaccia REST di controllo
                - Avvia l&#39;interfaccia web di gestione
                - Legge i buffer di notifiche in sospeso dal database
                &#34;&#34;&#34;
                params = [
                        {&#39;short&#39;: &#39;c&#39;, &#39;full&#39;: &#39;config&#39;, &#39;args&#39;: True, &#39;default&#39;: &#39;.&#39;,
                         &#39;help&#39;: &#39;Usa il file di configurazione dal percorso specificato.\nSe non è dato nessun percorso, viene preso quello di avvio del programma.&#39;},
                        {&#39;short&#39;: &#39;g&#39;, &#39;full&#39;: &#39;gui&#39;, &#39;args&#39;: True, &#39;default&#39;: &#39;&#39;, &#39;help&#39;:
                         &#39;&#39;&#39;Avvia l\&#39;interfaccia web del centro di controllo solo con alcune sezioni.
I parametri possibili sono:
\tmanager\t  Creazione e gestione delle notifiche
\tpreview\t  Anteprima della notifica (funzione sperimentale)
\tlist\t  Informazioni e gestione dei Butlers collegati&#39;&#39;&#39;},
                        {&#39;short&#39;: &#39;n&#39;, &#39;full&#39;: &#39;no_gui&#39;, &#39;args&#39;: False, &#39;default&#39;: &#39;&#39;, &#39;help&#39;:
                         &#39;&#39;&#39;Non avvia l&#39;interfaccia web.
Il server rimane raggiungibile attraverso richieste REST.&#39;&#39;&#39;},
                        {&#39;short&#39;: &#39;p&#39;, &#39;full&#39;: &#39;passive&#39;, &#39;args&#39;: False, &#39;default&#39;: &#39;&#39;,
                         &#39;help&#39;: &#39;Ignora il buffer delle notifiche.&#39;}
                ]
                argsParser = ArgsParser(params)
                args = argsParser.parse()
                try:
                        self.configs = ConfigParser().load_configs(args[&#39;config&#39;])
                except FileNotFoundError as e:
                        log.critical(
                                &#39;Impossibile leggere il file di configurazione:\n{}&#39;.format(e.__str__()))
                        return
                except JSONDecodeError as e:
                        log.critical(
                                &#39;Errore nella decodifica del file di configurazione:\n{}&#39;.format(e.__str__()))
                        return

                Logger().start(**self.configs[&#39;logging&#39;])
                self.ipParser = IPParser()
                self.expireTime = self.configs[&#39;expireTime&#39;]
                self.protocol = self.configs[&#39;protocol&#39;]
                self.serverConf = self.configs[&#39;server&#39;]
                self.controlConf = self.configs[&#39;controlCenter&#39;]
                self.guiConf = self.configs[&#39;gui&#39;]
                self.testNotifData = &#39;&#39;

                self.addr = &#39;{}://{}:{}&#39;.format(self.protocol,
                                                                                self.serverConf[&#39;ip&#39;], self.serverConf[&#39;port&#39;])
                self.id = self.serverConf[&#39;id&#39;]
                log.info(&#39;Avvio del server su {}&#39;.format(self.addr))

                # avvio dell&#39;ascoltatore dei Butlers
                butlerCallbacks = {&#39;add_butler&#39;: self.add_butler,
                                         &#39;disconnect&#39;: self.disconnect_client,
                                         &#39;interacted&#39;: self.interacted, &#39;update_db_details&#39;: self.update_db_details,
                                         &#39;butler_exists&#39;: self.butler_exists}

                self.butlerApi = ButlerAPI(self.serverConf[&#39;ip&#39;], self.serverConf[&#39;port&#39;],
                                                         self.expireTime, self.configs[&#39;ssl&#39;], butlerCallbacks,
                                                         )
                threading.Thread(target=self.butlerApi.start_api, daemon=True).start()

                # imposta e avvia l&#39;API del centro di controllo
                controlCenterAddr = &#39;{}://{}:{}&#39;.format(
                        self.protocol, self.controlConf[&#39;ip&#39;], self.controlConf[&#39;port&#39;])
                self.dbHelper = DbHelper()
                self.dbHelper.login(**self.configs[&#34;database&#34;])

                controlCallbacks = {&#39;send_notif&#39;: self.send_notif, &#39;check_butlers&#39;: self.check_butlers,
                                          &#39;can_disconnect&#39;: self.can_disconnect, &#39;force_disconnect&#39;: self.force_disconnect,
                                          &#39;get_files&#39;: self.get_files_list, &#39;revoke&#39;: self.revoke,
                                          &#39;validate_credentials&#39;: self.validate_credentials,
                                          &#39;test_notif&#39;: self.test_notif,
                                          &#39;get_butler_details&#39;: self.get_butler_details,
                                          &#39;set_butler_details&#39;: self.set_butler_details,
                                          &#39;edit_butler&#39;: self.edit_butler, &#39;apply_standard_model&#39;: self.apply_standard_model}

                sections = args[&#39;gui&#39;].split(
                        &#39;,&#39;) if args[&#39;gui&#39;] != &#39;&#39; else self.guiConf[&#39;sections&#39;]

                self.controlCenterApi = ControlCenterAPI(self.controlConf[&#39;ip&#39;], self.controlConf[&#39;port&#39;],
                                                                                   self.configs[&#39;expireTime&#39;], self.configs[&#39;ssl&#39;], controlCallbacks,
                                                                                   self.dbHelper, self.configs[&#39;imagesPath&#39;], self.controlConf[&#39;previewPort&#39;],
                                                                                   &#39;{}://{}:{}&#39;.format(self.protocol, self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;]), sections)
                threading.Thread(target=self.controlCenterApi.start_api, daemon=True).start()

                # avvio del controllo del buffer
                if self.configs[&#39;bufferTimer&#39;] &gt;= 1 and not args[&#39;passive&#39;]:
                        threading.Thread(target=self.check_buffer, args=[
                                self.configs[&#39;bufferTimer&#39;]], daemon=True).start()

                # prepara l&#39;interfaccia grafica del server
                guiAddr = &#39;{}://{}:{}&#39;.format(
                        self.protocol, self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;])

                self.controlCenterGui = ControlCenterGUI(self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;],
                                                                                   controlCenterAddr, self.configs[&#39;ssl&#39;], self.configs[&#39;gui&#39;][&#39;templatesPath&#39;], self.configs[&#39;gui&#39;][&#39;resPath&#39;])
                threading.Thread(target=self.controlCenterGui.start_api, daemon=True).start()

                # se necessario, apre una finestra del browser per la GUI
                if not args[&#39;no_gui&#39;]:
                        webbrowser.open(guiAddr, new=2, autoraise=False)

                notifBuilder = NotificationBuilder(
                        logoPath=self.configs[&#39;logoPath&#39;], testing=True)

                try:
                        while True:
                                if self.testNotifData != &#39;&#39;:
                                        log.warning(&#39;Test reale della notifica &#34;{}&#34;&#39;.format(
                                                self.testNotifData[&#39;name&#39;]))
                                        notifBuilder.interrupt = False
                                        notifBuilder.show_window(self.testNotifData)
                                        self.testNotifData = &#39;&#39;
                                sleep(self.TIMER)

                except KeyboardInterrupt:
                        sys.exit()

        def check_buffer(self, timer):
                &#34;&#34;&#34;
                Controlla periodicamente il buffer delle notifiche in sospeso,
                se il parametro è maggiore o uguale a 1 secondo.
                
                :param timer (int): il tempo di attesa tra i controlli (in secondi).
                &#34;&#34;&#34;
                log.info(&#39;Inizio del controllo del buffer&#39;)
                try:
                        while True:
                                for b in self.dbHelper.get_buffer():
                                        log.info(&#39;Tentativo di invio della notifica &#34;{}&#34; dal buffer&#39;.format(
                                                b[&#39;notification&#39;]))
                                        for addr in self.send_notif(b[&#39;notification&#39;], b[&#39;recipients&#39;], b[&#39;excluded&#39;]):
                                                if self.butlers[addr].ip not in b[&#39;excluded&#39;]:
                                                        b[&#39;excluded&#39;].append(self.butlers[addr].ip)
                                                log.info(&#39;Notifica &#34;{}&#34; inviata a {}&#39;.format(b[&#39;notification&#39;], addr))
                                        self.dbHelper.update_buffer(b)
                                        sleep(1)
                                sleep(timer)
                except KeyboardInterrupt:
                        sys.exit()

        def send_notif(self, name, recipients, excluded=[]):
                &#34;&#34;&#34;
                Generatore per inviare notifiche e ritornare gli indirizzi di chi ha
                ricevuto i messaggi.
                
                :param name (str): il nome della notifica.
                :param recipients (list): la lista degli indirizzi dei destinatari.
                :param excluded (list): la lista degli indirizzi da non considerare.
                        Default: [].
                
                :yield: gli indirizzi di chi ha risposto all&#39;invio della notifica.
                &#34;&#34;&#34;
                # la wildcard * viene sostituita da tutti i destinatari
                if recipients == [&#39;*&#39;]:
                        recipients = [self.butlers[addr].ip for addr in self.butlers]
                # i destinatari vengono rimossi se presenti tra quelli esclusi
                recipients = [addr for addr in recipients if addr not in excluded]

                log.warning(&#39;Invio di &#34;{}&#34; a {} Butler&#39;.format(name, len(recipients)))
                for addr in self.butlers:
                        if self.butlers[addr].ip not in excluded and self.ipParser.include(recipients, self.butlers[addr].ip):
                                data = self.parse_notif_data(self.dbHelper.get_notif_data(name))
                                received = self.butlers[addr].send({&#39;notifData&#39;: data})
                                if received:
                                        log.info(&#39;{} ha ricevuto &#34;{}&#34;&#39;.format(addr, name))
                                        yield addr

        def validate_credentials(self, user, password):
                &#34;&#34;&#34;
                Controlla che le credenziali passate corrispondano a quelle memorizzate
                nel file di configurazione.
                La pasword è salvata come SHA265.
                
                :param user (str): il nome utente dell&#39;amministratore.
                :param password (str): la password dell&#39;amministratore.
                
                :return: True se le credenziali corrispondono.
                &#34;&#34;&#34;
                return user == self.configs[&#39;username&#39;] and hashlib.sha256(password.lower().encode(&#34;utf&#34;)).hexdigest() == self.configs[&#39;password&#39;].lower()

        def add_butler(self, mac, addr, user):
                &#34;&#34;&#34;
                Crea un oggetto Butler e, se è possibile stabilire una connessione,
                lo aggiunge alla lista. 
                
                :param mac (str): l&#39;indirizzo MAC del computer.
                :param addr (str): l&#39;indirizzo IPv4 del Butler.
                :param user (str): il nome dell&#39;utente.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        return self.butlers[addr].get_status()

                b = Butler(self.protocol, mac, addr, user, self.addr, self.id)
                if b.authenticate():
                        log.info(&#39;Autenticazione con {} riuscita, aggiunto alla lista.&#39;.format(addr))
                        # la deepcopy permette di passare una versione dell&#39;oggetto, non un riferimento
                        self.butlers[addr] = copy.deepcopy(b)
                        threading.Thread(target=self.set_butler_details, args=[addr]).start()
                        return True
                else:
                        log.warning(&#39;Non è possibile stabilire la comunicazione con {}&#39;.format(addr))
                        del b
                        return False

        def disconnect_client(self, addr):
                &#34;&#34;&#34;
                Disconnette un client se ne ha il permesso.

                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da disconnettere.

                :return: True è stato possibile rimuovere il Butler dalla lista,
                        False in caso sia ancora connesso.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        if self.butlers[addr].canDisconnect:
                                log.warning(&#39;Disconnessione di {} avvenuta&#39;.format(addr))
                                self.butlers[addr].disconnect()
                                # se non c&#39;è la chiave, ritorna &#39;&#39;
                                self.butlers.pop(addr, &#39;&#39;)
                        else:
                                return False
                return True

        def interacted(self, addr, notifName):
                &#34;&#34;&#34;
                Aggiunge il Butler alla lista di host che hanno interagito con una certa notifica.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                :param notifName (str): il nome della notifica.
                &#34;&#34;&#34;
                if addr != &#39;&#39; and len(self.butlers) &gt; 0:
                        self.interactions[notifName].append(self.butlers[addr].address)

        def check_butlers(self, addr=&#39;&#39;):
                &#34;&#34;&#34;
                Verifica lo stato dei Butlers.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da controllare.
                        Default: &#39;&#39;.
                
                :return: la lista con le informazioni dei Butler ancora connessi.
                        È sempre ritornato almeno l&#39;indirizzo, ma se questo non è allegato
                        ad altri dati significa che il Butler non è attivo: in questo modo
                        è possibile verificare chi è andato offline rispetto all&#39;ultimo controllo.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        if self.butlers[addr].get_status():
                                return [{&#39;addr&#39;: addr, &#39;user&#39;: self.butlers[addr].user,
                                                        &#39;mac&#39;: self.butlers[addr].mac,
                                                        &#39;canDisconnect&#39;: self.butlers[addr].canDisconnect}]
                        else:
                                del self.butlers[addr]
                elif addr == &#39;&#39;:
                        # se l&#39;indirizzo è vuoto, vengono verificati tutti i Butlers
                        butlersInfo = []
                        try:
                                for addr in self.butlers:
                                        if self.butlers[addr].get_status():
                                                butlersInfo.append({&#39;addr&#39;: addr,
                                                                                        &#39;user&#39;: self.butlers[addr].user,
                                                                                        &#39;mac&#39;: self.butlers[addr].mac,
                                                                                        &#39;canDisconnect&#39;: self.butlers[addr].canDisconnect})
                                        else:
                                                butlersInfo.append({&#39;addr&#39;: addr})
                        except Exception as e:
                                log.warning(
                                        &#39;Errore nella verifica dello stato dei Butlers: {}&#39;.format(e.__str__()))
                        for b in butlersInfo:
                                if &#39;user&#39; not in b and b[&#39;addr&#39;] in self.butlers:
                                        del self.butlers[b[&#39;addr&#39;]]
                        return butlersInfo

                return {&#39;addr&#39;: addr}

        def can_disconnect(self, addr, permission):
                &#34;&#34;&#34;
                Imposta il permesso di disconnessione di un client.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                :param permission (bool): il permesso di disconnessione.
                &#34;&#34;&#34;
                log.info(&#39;Cambio del permesso di disconnessione a {} in {}&#39;.format(addr, permission))
                if self.addr_exists(addr):
                        self.butlers[addr].canDisconnect = permission

        def force_disconnect(self, addr):
                &#34;&#34;&#34;
                Forza la disconnessione di un Butler impostando il permesso e inviando la richiesta.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                &#34;&#34;&#34;
                log.info(&#39;Richiesta di disconnessione a {}&#39;.format(addr))
                self.can_disconnect(addr, True)
                self.disconnect_client(addr)

        def revoke(self, name):
                &#34;&#34;&#34;
                Revoca una notifica da tutti i Butlers, chiedendo la sua chiusura.
                
                :param name (str): il nome della notifica da chiudere.
                &#34;&#34;&#34;
                for addr in self.butlers:
                        self.butlers[addr].revoke(name)

        def test_notif(self, data):
                &#34;&#34;&#34;
                Autoinvia una notifica per testarne unicamente lo stile.
                
                :param data (dict): i dati della notifica da mostrare.
                &#34;&#34;&#34;
                self.testNotifData = self.parse_notif_data(data)

        def get_files_list(self, pathKey):
                &#34;&#34;&#34;
                Legge un percorso apposito specificato nel file di configurazione e ritorna
                la lista dei file presenti.
                È usato per ricavare la lista di immagini e di scripts.
                
                :param pathKey (str): la chiave della configurazione corrispondente al
                        tipo di file richiesto.
                
                :return: la lista dei nomi dei file.
                &#34;&#34;&#34;

                return [f for f in os.listdir(abspath(join(sys.path[0], self.configs[pathKey]))) if isfile(join(sys.path[0], self.configs[pathKey], f))]

        def addr_exists(self, addr):
                &#34;&#34;&#34;
                Verifica che si possa accedere ai dati del Butler ricercandolo nella lista
                in base al suo indirizzo.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
                
                :return: True se esistono dati associati all&#39;indirizzo richiesto, False
                        in tutti gli altri casi.
                &#34;&#34;&#34;
                return len(self.butlers) &gt; 0 and addr != [] and addr != {} and addr in self.butlers

        def parse_notif_data(self, data):
                &#34;&#34;&#34;
                Modifica i dati della notifica sostituendo i percorsi relativi al server
                con i dati base64 del file in quel percorso. Se non esiste il file,
                il dato viene comunque passato come percorso assumento si tratti di
                una cartella presente localmente nel client.
                
                :param data (dict): i dati della notifica da modificare.
                
                :return: il dizionario dei dati pronto all&#39;uso.
                &#34;&#34;&#34;
                if &#39;style&#39; in data and data[&#39;style&#39;][&#39;image&#39;] != &#39;&#39;:
                        data[&#39;style&#39;][&#39;image&#39;] = self.get_file_data(
                                self.configs[&#39;imagesPath&#39;], data[&#39;style&#39;][&#39;image&#39;])
                if data[&#39;script&#39;][&#39;program&#39;] != &#39;&#39;:
                        data[&#39;script&#39;][&#39;program&#39;] += &#39; &#39;+basename(data[&#39;script&#39;][&#39;command&#39;])
                        data[&#39;script&#39;][&#39;command&#39;] = self.get_file_data(
                                self.configs[&#39;scriptsPath&#39;], data[&#39;script&#39;][&#39;command&#39;])
                else:
                        log.info(&#39;Script vuoto&#39;)

                return data

        def get_file_data(self, basePath, path):
                &#34;&#34;&#34;
                Tenta di leggere i dati del file nel percorso specificato.
                
                :param basePath (str): la base del percorso nel quale cercare.
                :param path (str): il percorso che specifica almeno il nome del file.
                
                :return: i dati base64 del file se esiste, altrimenti il suo percorso.
                &#34;&#34;&#34;
                try:
                        fullPath = abspath(join(sys.path[0], basePath, path))
                        if exists(path):
                                pass
                        elif exists(fullPath):
                                path = fullPath
                        with open(path, &#34;r+b&#34;) as file:
                                log.warning(
                                        &#39;È stato inviato il file in &#34;{}&#34; insieme ad una notifica&#39;.format(path))
                                return base64.b64encode(file.read()).decode()
                except Exception as e:
                        log.warning(
                                &#39;Il file verrà inviato come percorso a causa del seguente errore: {}&#39;.format(e.__str__()))
                log.warning(
                        &#39;È stato inviato il percorso &#34;{}&#34; insieme ad una notifica (non è stato trovato localmente)&#39;.format(path))
                return path

        &#34;&#34;&#34;
        #####################################
        Funzioni aggiuntive butler-extensions
        #####################################
        &#34;&#34;&#34;

        def edit_butler(self, addr, data, endpoint):
                &#34;&#34;&#34;
                Permette di modificare un parametro di un Butler.

                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da modificare.
                :param data (str): i dati da modificare.
                :param endpoint (str): l&#39;endpoint del Butler.
                &#34;&#34;&#34;
                if self.addr_exists(addr) and endpoint != &#39;&#39; and data != &#39;&#39;:
                        data[&#39;mac&#39;] = self.butlers[addr].mac
                        self.dbHelper.upsert_details(data)
                        self.butlers[addr].edit(data, endpoint)

        def apply_standard_model(self, addr):
                &#34;&#34;&#34;
                Invia i dati del modello standard ad un Butler.
                L&#39;operazione non viene effettuata completamente dal gestore del database,
                poichè alcuni dati devono poi essere inviati al client.
                
                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler al quale inviare i dati.

                :return: il numero di connessioni applicate.
                &#34;&#34;&#34;
                if self.addr_exists(addr):
                        # query al modello standard con MAC &#34;&#34;
                        standardModel = self.dbHelper.get_computer_data(self.STANDARD_MODEL_MAC)
                        if &#39;model&#39; in standardModel:
                                standardModel[&#39;mac&#39;] = self.butlers[addr].mac
                                self.dbHelper.upsert_details(standardModel)
                                self.butlers[addr].update_model(standardModel[&#39;model&#39;])
                                return len(standardModel[&#39;model&#39;])
                return 0

        def get_butler_details(self, addr):
                &#34;&#34;&#34;
                Richiede i dettagli al Butler e gestisce i valori vuoti che
                il client ritorna se non ha certi moduli attivi.

                :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler al quale richiedere i dati.

                :return: i dati ricevuti.
                &#34;&#34;&#34;
                if self.addr_exists(addr):

                        details = self.butlers[addr].get_details()
                        # se non ci sono dettagli, verifica che l&#39;host sia ancora connesso
                        if details == {}:
                                self.check_butlers()
                                return {}

                        self.set_butler_details(addr, details)
                        details = self.dbHelper.get_computer_data(self.butlers[addr].mac)

                        if &#39;inventory&#39; not in details:
                                details[&#39;inventory&#39;] = {}

                        if &#39;model&#39; not in details:
                                details[&#39;model&#39;] = {}
                                details[&#39;phase&#39;] = &#39;&#39;

                        # modules non deve essere gestito.
                        # Se manca, altre classi si accorgeranno dell&#39;errore

                        details[&#39;mac&#39;] = self.butlers[addr].mac
                        return details
                return {}

        def set_butler_details(self, addr, butlerDetails={}):
                &#34;&#34;&#34;
                Sincronizza le informazioni tra database e client
                garantendo la loro consistenza.

                :param addr (str): l&#39;indirizzo e la porta del quale verificare i dati.
                :param butlerDetails (dict): i dati del Butler, se già richiesti.
                        Default: {}.
                &#34;&#34;&#34;
                # i dettagli vengono presi prima di controllare se l&#39;host esiste
                # dato che questo potrebbe essere rimosso durante la chiamata
                if butlerDetails == {}:
                        butlerDetails = self.get_butler_details(addr)
                if self.addr_exists(addr) and butlerDetails != {}:
                        # i dati del modello del database hanno la precedenza su quelli del Butler
                        dbDetails = self.dbHelper.get_computer_data(self.butlers[addr].mac)

                        sameAttr = []
                        for attr in butlerDetails:
                                # verifica che l&#39;attributo esista in entrambi gli array
                                # e che i valori corrispondano, oppure che abbiamo dimensione uguale
                                if attr in dbDetails and (butlerDetails[attr] == dbDetails[attr] or isinstance(butlerDetails[attr], list) and len(butlerDetails[attr]) == len(dbDetails[attr])):
                                        sameAttr.append(attr)
                        for attr in sameAttr:
                                del butlerDetails[attr]
                                del dbDetails[attr]

                        # i dati dell&#39;inventario presi dal Butler hanno la precedenza su quelli del database
                        if &#39;inventory&#39; in butlerDetails:
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;inventory&#39;: butlerDetails[&#39;inventory&#39;]})

                        if &#39;model&#39; in dbDetails:
                                if &#39;model&#39; in butlerDetails and len(butlerDetails[&#39;model&#39;]) &gt; len(dbDetails[&#39;model&#39;]):
                                        self.dbHelper.upsert_details(
                                                {&#39;mac&#39;: self.butlers[addr].mac, &#39;model&#39;: butlerDetails[&#39;model&#39;]})

                                self.butlers[addr].update_model(dbDetails[&#39;model&#39;])
                                if &#39;phase&#39; in dbDetails:
                                        self.butlers[addr].edit({&#39;phase&#39;: dbDetails[&#39;phase&#39;]}, &#39;/phase&#39;)
                                        
                        # solo se il database non ha informazioni a riguardo vengono prese
                        # direttamente quelle del Butler
                        elif &#39;model&#39; in butlerDetails:
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;model&#39;: butlerDetails[&#39;model&#39;]})
                                # se il database ha tutti i dati, ma manda il modello
                                # è probabile che il client non invii anche la fase
                                if &#39;phase&#39; in butlerDetails:
                                        self.dbHelper.upsert_details(
                                                {&#39;mac&#39;: self.butlers[addr].mac, &#39;phase&#39;: butlerDetails[&#39;phase&#39;]})

                        # anche i moduli hanno la precedenza se presenti nel database
                        if &#39;modules&#39; in dbDetails:
                                self.butlers[addr].edit({&#39;modules&#39;: dbDetails[&#39;modules&#39;]}, &#39;/module&#39;)
                        elif &#39;modules&#39; in butlerDetails:
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;modules&#39;: butlerDetails[&#39;modules&#39;]})

        def update_db_details(self, details):
                &#34;&#34;&#34;
                Aggiorna le informazioni ricevute dal Butler nel database.

                :param details (dict): i dati da aggiornare.
                &#34;&#34;&#34;
                self.dbHelper.upsert_details(details)

        def butler_exists(self, addr):
                &#34;&#34;&#34;
                Controlla se l&#39;indirizzo passato fa parte dell&#39;array di Butlers
                
                :param addr (str): l&#39;indirizzo identificativo.
                
                :return True se è presente, altrimenti False.
                &#34;&#34;&#34;
                return addr in self.butlers

        &#34;&#34;&#34;
        ##########################################
        Fine funzioni aggiuntive butler-extensions
        ##########################################
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.server.manager.Manager.STANDARD_MODEL_MAC"><code class="name">var <span class="ident">STANDARD_MODEL_MAC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.server.manager.Manager.TIMER"><code class="name">var <span class="ident">TIMER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.server.manager.Manager.butlers"><code class="name">var <span class="ident">butlers</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.server.manager.Manager.collMap"><code class="name">var <span class="ident">collMap</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.server.manager.Manager.interactions"><code class="name">var <span class="ident">interactions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.server.manager.Manager.add_butler"><code class="name flex">
<span>def <span class="ident">add_butler</span></span>(<span>self, mac, addr, user)</span>
</code></dt>
<dd>
<div class="desc"><p>Crea un oggetto Butler e, se è possibile stabilire una connessione,
lo aggiunge alla lista. </p>
<p>:param mac (str): l'indirizzo MAC del computer.
:param addr (str): l'indirizzo IPv4 del Butler.
:param user (str): il nome dell'utente.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_butler(self, mac, addr, user):
        &#34;&#34;&#34;
        Crea un oggetto Butler e, se è possibile stabilire una connessione,
        lo aggiunge alla lista. 
        
        :param mac (str): l&#39;indirizzo MAC del computer.
        :param addr (str): l&#39;indirizzo IPv4 del Butler.
        :param user (str): il nome dell&#39;utente.
        &#34;&#34;&#34;
        if self.addr_exists(addr):
                return self.butlers[addr].get_status()

        b = Butler(self.protocol, mac, addr, user, self.addr, self.id)
        if b.authenticate():
                log.info(&#39;Autenticazione con {} riuscita, aggiunto alla lista.&#39;.format(addr))
                # la deepcopy permette di passare una versione dell&#39;oggetto, non un riferimento
                self.butlers[addr] = copy.deepcopy(b)
                threading.Thread(target=self.set_butler_details, args=[addr]).start()
                return True
        else:
                log.warning(&#39;Non è possibile stabilire la comunicazione con {}&#39;.format(addr))
                del b
                return False</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.addr_exists"><code class="name flex">
<span>def <span class="ident">addr_exists</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifica che si possa accedere ai dati del Butler ricercandolo nella lista
in base al suo indirizzo.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler.</p>
<p>:return: True se esistono dati associati all'indirizzo richiesto, False
in tutti gli altri casi.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addr_exists(self, addr):
        &#34;&#34;&#34;
        Verifica che si possa accedere ai dati del Butler ricercandolo nella lista
        in base al suo indirizzo.
        
        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
        
        :return: True se esistono dati associati all&#39;indirizzo richiesto, False
                in tutti gli altri casi.
        &#34;&#34;&#34;
        return len(self.butlers) &gt; 0 and addr != [] and addr != {} and addr in self.butlers</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.apply_standard_model"><code class="name flex">
<span>def <span class="ident">apply_standard_model</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Invia i dati del modello standard ad un Butler.
L'operazione non viene effettuata completamente dal gestore del database,
poichè alcuni dati devono poi essere inviati al client.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler al quale inviare i dati.</p>
<p>:return: il numero di connessioni applicate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_standard_model(self, addr):
        &#34;&#34;&#34;
        Invia i dati del modello standard ad un Butler.
        L&#39;operazione non viene effettuata completamente dal gestore del database,
        poichè alcuni dati devono poi essere inviati al client.
        
        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler al quale inviare i dati.

        :return: il numero di connessioni applicate.
        &#34;&#34;&#34;
        if self.addr_exists(addr):
                # query al modello standard con MAC &#34;&#34;
                standardModel = self.dbHelper.get_computer_data(self.STANDARD_MODEL_MAC)
                if &#39;model&#39; in standardModel:
                        standardModel[&#39;mac&#39;] = self.butlers[addr].mac
                        self.dbHelper.upsert_details(standardModel)
                        self.butlers[addr].update_model(standardModel[&#39;model&#39;])
                        return len(standardModel[&#39;model&#39;])
        return 0</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.butler_exists"><code class="name flex">
<span>def <span class="ident">butler_exists</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Controlla se l'indirizzo passato fa parte dell'array di Butlers</p>
<p>:param addr (str): l'indirizzo identificativo.</p>
<p>:return True se è presente, altrimenti False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def butler_exists(self, addr):
        &#34;&#34;&#34;
        Controlla se l&#39;indirizzo passato fa parte dell&#39;array di Butlers
        
        :param addr (str): l&#39;indirizzo identificativo.
        
        :return True se è presente, altrimenti False.
        &#34;&#34;&#34;
        return addr in self.butlers</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.can_disconnect"><code class="name flex">
<span>def <span class="ident">can_disconnect</span></span>(<span>self, addr, permission)</span>
</code></dt>
<dd>
<div class="desc"><p>Imposta il permesso di disconnessione di un client.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler.
:param permission (bool): il permesso di disconnessione.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_disconnect(self, addr, permission):
        &#34;&#34;&#34;
        Imposta il permesso di disconnessione di un client.
        
        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
        :param permission (bool): il permesso di disconnessione.
        &#34;&#34;&#34;
        log.info(&#39;Cambio del permesso di disconnessione a {} in {}&#39;.format(addr, permission))
        if self.addr_exists(addr):
                self.butlers[addr].canDisconnect = permission</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.check_buffer"><code class="name flex">
<span>def <span class="ident">check_buffer</span></span>(<span>self, timer)</span>
</code></dt>
<dd>
<div class="desc"><p>Controlla periodicamente il buffer delle notifiche in sospeso,
se il parametro è maggiore o uguale a 1 secondo.</p>
<p>:param timer (int): il tempo di attesa tra i controlli (in secondi).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_buffer(self, timer):
        &#34;&#34;&#34;
        Controlla periodicamente il buffer delle notifiche in sospeso,
        se il parametro è maggiore o uguale a 1 secondo.
        
        :param timer (int): il tempo di attesa tra i controlli (in secondi).
        &#34;&#34;&#34;
        log.info(&#39;Inizio del controllo del buffer&#39;)
        try:
                while True:
                        for b in self.dbHelper.get_buffer():
                                log.info(&#39;Tentativo di invio della notifica &#34;{}&#34; dal buffer&#39;.format(
                                        b[&#39;notification&#39;]))
                                for addr in self.send_notif(b[&#39;notification&#39;], b[&#39;recipients&#39;], b[&#39;excluded&#39;]):
                                        if self.butlers[addr].ip not in b[&#39;excluded&#39;]:
                                                b[&#39;excluded&#39;].append(self.butlers[addr].ip)
                                        log.info(&#39;Notifica &#34;{}&#34; inviata a {}&#39;.format(b[&#39;notification&#39;], addr))
                                self.dbHelper.update_buffer(b)
                                sleep(1)
                        sleep(timer)
        except KeyboardInterrupt:
                sys.exit()</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.check_butlers"><code class="name flex">
<span>def <span class="ident">check_butlers</span></span>(<span>self, addr='')</span>
</code></dt>
<dd>
<div class="desc"><p>Verifica lo stato dei Butlers.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler da controllare.
Default: ''.</p>
<p>:return: la lista con le informazioni dei Butler ancora connessi.
È sempre ritornato almeno l'indirizzo, ma se questo non è allegato
ad altri dati significa che il Butler non è attivo: in questo modo
è possibile verificare chi è andato offline rispetto all'ultimo controllo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_butlers(self, addr=&#39;&#39;):
        &#34;&#34;&#34;
        Verifica lo stato dei Butlers.
        
        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da controllare.
                Default: &#39;&#39;.
        
        :return: la lista con le informazioni dei Butler ancora connessi.
                È sempre ritornato almeno l&#39;indirizzo, ma se questo non è allegato
                ad altri dati significa che il Butler non è attivo: in questo modo
                è possibile verificare chi è andato offline rispetto all&#39;ultimo controllo.
        &#34;&#34;&#34;
        if self.addr_exists(addr):
                if self.butlers[addr].get_status():
                        return [{&#39;addr&#39;: addr, &#39;user&#39;: self.butlers[addr].user,
                                                &#39;mac&#39;: self.butlers[addr].mac,
                                                &#39;canDisconnect&#39;: self.butlers[addr].canDisconnect}]
                else:
                        del self.butlers[addr]
        elif addr == &#39;&#39;:
                # se l&#39;indirizzo è vuoto, vengono verificati tutti i Butlers
                butlersInfo = []
                try:
                        for addr in self.butlers:
                                if self.butlers[addr].get_status():
                                        butlersInfo.append({&#39;addr&#39;: addr,
                                                                                &#39;user&#39;: self.butlers[addr].user,
                                                                                &#39;mac&#39;: self.butlers[addr].mac,
                                                                                &#39;canDisconnect&#39;: self.butlers[addr].canDisconnect})
                                else:
                                        butlersInfo.append({&#39;addr&#39;: addr})
                except Exception as e:
                        log.warning(
                                &#39;Errore nella verifica dello stato dei Butlers: {}&#39;.format(e.__str__()))
                for b in butlersInfo:
                        if &#39;user&#39; not in b and b[&#39;addr&#39;] in self.butlers:
                                del self.butlers[b[&#39;addr&#39;]]
                return butlersInfo

        return {&#39;addr&#39;: addr}</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.disconnect_client"><code class="name flex">
<span>def <span class="ident">disconnect_client</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnette un client se ne ha il permesso.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler da disconnettere.</p>
<p>:return: True è stato possibile rimuovere il Butler dalla lista,
False in caso sia ancora connesso.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_client(self, addr):
        &#34;&#34;&#34;
        Disconnette un client se ne ha il permesso.

        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da disconnettere.

        :return: True è stato possibile rimuovere il Butler dalla lista,
                False in caso sia ancora connesso.
        &#34;&#34;&#34;
        if self.addr_exists(addr):
                if self.butlers[addr].canDisconnect:
                        log.warning(&#39;Disconnessione di {} avvenuta&#39;.format(addr))
                        self.butlers[addr].disconnect()
                        # se non c&#39;è la chiave, ritorna &#39;&#39;
                        self.butlers.pop(addr, &#39;&#39;)
                else:
                        return False
        return True</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.edit_butler"><code class="name flex">
<span>def <span class="ident">edit_butler</span></span>(<span>self, addr, data, endpoint)</span>
</code></dt>
<dd>
<div class="desc"><p>Permette di modificare un parametro di un Butler.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler da modificare.
:param data (str): i dati da modificare.
:param endpoint (str): l'endpoint del Butler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_butler(self, addr, data, endpoint):
        &#34;&#34;&#34;
        Permette di modificare un parametro di un Butler.

        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler da modificare.
        :param data (str): i dati da modificare.
        :param endpoint (str): l&#39;endpoint del Butler.
        &#34;&#34;&#34;
        if self.addr_exists(addr) and endpoint != &#39;&#39; and data != &#39;&#39;:
                data[&#39;mac&#39;] = self.butlers[addr].mac
                self.dbHelper.upsert_details(data)
                self.butlers[addr].edit(data, endpoint)</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.force_disconnect"><code class="name flex">
<span>def <span class="ident">force_disconnect</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Forza la disconnessione di un Butler impostando il permesso e inviando la richiesta.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_disconnect(self, addr):
        &#34;&#34;&#34;
        Forza la disconnessione di un Butler impostando il permesso e inviando la richiesta.
        
        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
        &#34;&#34;&#34;
        log.info(&#39;Richiesta di disconnessione a {}&#39;.format(addr))
        self.can_disconnect(addr, True)
        self.disconnect_client(addr)</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.get_butler_details"><code class="name flex">
<span>def <span class="ident">get_butler_details</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Richiede i dettagli al Butler e gestisce i valori vuoti che
il client ritorna se non ha certi moduli attivi.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler al quale richiedere i dati.</p>
<p>:return: i dati ricevuti.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_butler_details(self, addr):
        &#34;&#34;&#34;
        Richiede i dettagli al Butler e gestisce i valori vuoti che
        il client ritorna se non ha certi moduli attivi.

        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler al quale richiedere i dati.

        :return: i dati ricevuti.
        &#34;&#34;&#34;
        if self.addr_exists(addr):

                details = self.butlers[addr].get_details()
                # se non ci sono dettagli, verifica che l&#39;host sia ancora connesso
                if details == {}:
                        self.check_butlers()
                        return {}

                self.set_butler_details(addr, details)
                details = self.dbHelper.get_computer_data(self.butlers[addr].mac)

                if &#39;inventory&#39; not in details:
                        details[&#39;inventory&#39;] = {}

                if &#39;model&#39; not in details:
                        details[&#39;model&#39;] = {}
                        details[&#39;phase&#39;] = &#39;&#39;

                # modules non deve essere gestito.
                # Se manca, altre classi si accorgeranno dell&#39;errore

                details[&#39;mac&#39;] = self.butlers[addr].mac
                return details
        return {}</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.get_file_data"><code class="name flex">
<span>def <span class="ident">get_file_data</span></span>(<span>self, basePath, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Tenta di leggere i dati del file nel percorso specificato.</p>
<p>:param basePath (str): la base del percorso nel quale cercare.
:param path (str): il percorso che specifica almeno il nome del file.</p>
<p>:return: i dati base64 del file se esiste, altrimenti il suo percorso.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_data(self, basePath, path):
        &#34;&#34;&#34;
        Tenta di leggere i dati del file nel percorso specificato.
        
        :param basePath (str): la base del percorso nel quale cercare.
        :param path (str): il percorso che specifica almeno il nome del file.
        
        :return: i dati base64 del file se esiste, altrimenti il suo percorso.
        &#34;&#34;&#34;
        try:
                fullPath = abspath(join(sys.path[0], basePath, path))
                if exists(path):
                        pass
                elif exists(fullPath):
                        path = fullPath
                with open(path, &#34;r+b&#34;) as file:
                        log.warning(
                                &#39;È stato inviato il file in &#34;{}&#34; insieme ad una notifica&#39;.format(path))
                        return base64.b64encode(file.read()).decode()
        except Exception as e:
                log.warning(
                        &#39;Il file verrà inviato come percorso a causa del seguente errore: {}&#39;.format(e.__str__()))
        log.warning(
                &#39;È stato inviato il percorso &#34;{}&#34; insieme ad una notifica (non è stato trovato localmente)&#39;.format(path))
        return path</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.get_files_list"><code class="name flex">
<span>def <span class="ident">get_files_list</span></span>(<span>self, pathKey)</span>
</code></dt>
<dd>
<div class="desc"><p>Legge un percorso apposito specificato nel file di configurazione e ritorna
la lista dei file presenti.
È usato per ricavare la lista di immagini e di scripts.</p>
<p>:param pathKey (str): la chiave della configurazione corrispondente al
tipo di file richiesto.</p>
<p>:return: la lista dei nomi dei file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files_list(self, pathKey):
        &#34;&#34;&#34;
        Legge un percorso apposito specificato nel file di configurazione e ritorna
        la lista dei file presenti.
        È usato per ricavare la lista di immagini e di scripts.
        
        :param pathKey (str): la chiave della configurazione corrispondente al
                tipo di file richiesto.
        
        :return: la lista dei nomi dei file.
        &#34;&#34;&#34;

        return [f for f in os.listdir(abspath(join(sys.path[0], self.configs[pathKey]))) if isfile(join(sys.path[0], self.configs[pathKey], f))]</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.interacted"><code class="name flex">
<span>def <span class="ident">interacted</span></span>(<span>self, addr, notifName)</span>
</code></dt>
<dd>
<div class="desc"><p>Aggiunge il Butler alla lista di host che hanno interagito con una certa notifica.</p>
<p>:param addr (str): l'indirizzo IPv4 e la porta del Butler.
:param notifName (str): il nome della notifica.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interacted(self, addr, notifName):
        &#34;&#34;&#34;
        Aggiunge il Butler alla lista di host che hanno interagito con una certa notifica.
        
        :param addr (str): l&#39;indirizzo IPv4 e la porta del Butler.
        :param notifName (str): il nome della notifica.
        &#34;&#34;&#34;
        if addr != &#39;&#39; and len(self.butlers) &gt; 0:
                self.interactions[notifName].append(self.butlers[addr].address)</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.parse_notif_data"><code class="name flex">
<span>def <span class="ident">parse_notif_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifica i dati della notifica sostituendo i percorsi relativi al server
con i dati base64 del file in quel percorso. Se non esiste il file,
il dato viene comunque passato come percorso assumento si tratti di
una cartella presente localmente nel client.</p>
<p>:param data (dict): i dati della notifica da modificare.</p>
<p>:return: il dizionario dei dati pronto all'uso.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_notif_data(self, data):
        &#34;&#34;&#34;
        Modifica i dati della notifica sostituendo i percorsi relativi al server
        con i dati base64 del file in quel percorso. Se non esiste il file,
        il dato viene comunque passato come percorso assumento si tratti di
        una cartella presente localmente nel client.
        
        :param data (dict): i dati della notifica da modificare.
        
        :return: il dizionario dei dati pronto all&#39;uso.
        &#34;&#34;&#34;
        if &#39;style&#39; in data and data[&#39;style&#39;][&#39;image&#39;] != &#39;&#39;:
                data[&#39;style&#39;][&#39;image&#39;] = self.get_file_data(
                        self.configs[&#39;imagesPath&#39;], data[&#39;style&#39;][&#39;image&#39;])
        if data[&#39;script&#39;][&#39;program&#39;] != &#39;&#39;:
                data[&#39;script&#39;][&#39;program&#39;] += &#39; &#39;+basename(data[&#39;script&#39;][&#39;command&#39;])
                data[&#39;script&#39;][&#39;command&#39;] = self.get_file_data(
                        self.configs[&#39;scriptsPath&#39;], data[&#39;script&#39;][&#39;command&#39;])
        else:
                log.info(&#39;Script vuoto&#39;)

        return data</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.revoke"><code class="name flex">
<span>def <span class="ident">revoke</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Revoca una notifica da tutti i Butlers, chiedendo la sua chiusura.</p>
<p>:param name (str): il nome della notifica da chiudere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revoke(self, name):
        &#34;&#34;&#34;
        Revoca una notifica da tutti i Butlers, chiedendo la sua chiusura.
        
        :param name (str): il nome della notifica da chiudere.
        &#34;&#34;&#34;
        for addr in self.butlers:
                self.butlers[addr].revoke(name)</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.send_notif"><code class="name flex">
<span>def <span class="ident">send_notif</span></span>(<span>self, name, recipients, excluded=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Generatore per inviare notifiche e ritornare gli indirizzi di chi ha
ricevuto i messaggi.</p>
<p>:param name (str): il nome della notifica.
:param recipients (list): la lista degli indirizzi dei destinatari.
:param excluded (list): la lista degli indirizzi da non considerare.
Default: [].</p>
<p>:yield: gli indirizzi di chi ha risposto all'invio della notifica.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_notif(self, name, recipients, excluded=[]):
        &#34;&#34;&#34;
        Generatore per inviare notifiche e ritornare gli indirizzi di chi ha
        ricevuto i messaggi.
        
        :param name (str): il nome della notifica.
        :param recipients (list): la lista degli indirizzi dei destinatari.
        :param excluded (list): la lista degli indirizzi da non considerare.
                Default: [].
        
        :yield: gli indirizzi di chi ha risposto all&#39;invio della notifica.
        &#34;&#34;&#34;
        # la wildcard * viene sostituita da tutti i destinatari
        if recipients == [&#39;*&#39;]:
                recipients = [self.butlers[addr].ip for addr in self.butlers]
        # i destinatari vengono rimossi se presenti tra quelli esclusi
        recipients = [addr for addr in recipients if addr not in excluded]

        log.warning(&#39;Invio di &#34;{}&#34; a {} Butler&#39;.format(name, len(recipients)))
        for addr in self.butlers:
                if self.butlers[addr].ip not in excluded and self.ipParser.include(recipients, self.butlers[addr].ip):
                        data = self.parse_notif_data(self.dbHelper.get_notif_data(name))
                        received = self.butlers[addr].send({&#39;notifData&#39;: data})
                        if received:
                                log.info(&#39;{} ha ricevuto &#34;{}&#34;&#39;.format(addr, name))
                                yield addr</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.set_butler_details"><code class="name flex">
<span>def <span class="ident">set_butler_details</span></span>(<span>self, addr, butlerDetails={})</span>
</code></dt>
<dd>
<div class="desc"><p>Sincronizza le informazioni tra database e client
garantendo la loro consistenza.</p>
<p>:param addr (str): l'indirizzo e la porta del quale verificare i dati.
:param butlerDetails (dict): i dati del Butler, se già richiesti.
Default: {}.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_butler_details(self, addr, butlerDetails={}):
        &#34;&#34;&#34;
        Sincronizza le informazioni tra database e client
        garantendo la loro consistenza.

        :param addr (str): l&#39;indirizzo e la porta del quale verificare i dati.
        :param butlerDetails (dict): i dati del Butler, se già richiesti.
                Default: {}.
        &#34;&#34;&#34;
        # i dettagli vengono presi prima di controllare se l&#39;host esiste
        # dato che questo potrebbe essere rimosso durante la chiamata
        if butlerDetails == {}:
                butlerDetails = self.get_butler_details(addr)
        if self.addr_exists(addr) and butlerDetails != {}:
                # i dati del modello del database hanno la precedenza su quelli del Butler
                dbDetails = self.dbHelper.get_computer_data(self.butlers[addr].mac)

                sameAttr = []
                for attr in butlerDetails:
                        # verifica che l&#39;attributo esista in entrambi gli array
                        # e che i valori corrispondano, oppure che abbiamo dimensione uguale
                        if attr in dbDetails and (butlerDetails[attr] == dbDetails[attr] or isinstance(butlerDetails[attr], list) and len(butlerDetails[attr]) == len(dbDetails[attr])):
                                sameAttr.append(attr)
                for attr in sameAttr:
                        del butlerDetails[attr]
                        del dbDetails[attr]

                # i dati dell&#39;inventario presi dal Butler hanno la precedenza su quelli del database
                if &#39;inventory&#39; in butlerDetails:
                        self.dbHelper.upsert_details(
                                {&#39;mac&#39;: self.butlers[addr].mac, &#39;inventory&#39;: butlerDetails[&#39;inventory&#39;]})

                if &#39;model&#39; in dbDetails:
                        if &#39;model&#39; in butlerDetails and len(butlerDetails[&#39;model&#39;]) &gt; len(dbDetails[&#39;model&#39;]):
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;model&#39;: butlerDetails[&#39;model&#39;]})

                        self.butlers[addr].update_model(dbDetails[&#39;model&#39;])
                        if &#39;phase&#39; in dbDetails:
                                self.butlers[addr].edit({&#39;phase&#39;: dbDetails[&#39;phase&#39;]}, &#39;/phase&#39;)
                                
                # solo se il database non ha informazioni a riguardo vengono prese
                # direttamente quelle del Butler
                elif &#39;model&#39; in butlerDetails:
                        self.dbHelper.upsert_details(
                                {&#39;mac&#39;: self.butlers[addr].mac, &#39;model&#39;: butlerDetails[&#39;model&#39;]})
                        # se il database ha tutti i dati, ma manda il modello
                        # è probabile che il client non invii anche la fase
                        if &#39;phase&#39; in butlerDetails:
                                self.dbHelper.upsert_details(
                                        {&#39;mac&#39;: self.butlers[addr].mac, &#39;phase&#39;: butlerDetails[&#39;phase&#39;]})

                # anche i moduli hanno la precedenza se presenti nel database
                if &#39;modules&#39; in dbDetails:
                        self.butlers[addr].edit({&#39;modules&#39;: dbDetails[&#39;modules&#39;]}, &#39;/module&#39;)
                elif &#39;modules&#39; in butlerDetails:
                        self.dbHelper.upsert_details(
                                {&#39;mac&#39;: self.butlers[addr].mac, &#39;modules&#39;: butlerDetails[&#39;modules&#39;]})</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Punto d'entrata del programma.
- Ascolta le richieste da qualunque Butlers
- Mette a disposizione l'interfaccia REST di controllo
- Avvia l'interfaccia web di gestione
- Legge i buffer di notifiche in sospeso dal database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def start(self):
                &#34;&#34;&#34;
                Punto d&#39;entrata del programma.
                - Ascolta le richieste da qualunque Butlers
                - Mette a disposizione l&#39;interfaccia REST di controllo
                - Avvia l&#39;interfaccia web di gestione
                - Legge i buffer di notifiche in sospeso dal database
                &#34;&#34;&#34;
                params = [
                        {&#39;short&#39;: &#39;c&#39;, &#39;full&#39;: &#39;config&#39;, &#39;args&#39;: True, &#39;default&#39;: &#39;.&#39;,
                         &#39;help&#39;: &#39;Usa il file di configurazione dal percorso specificato.\nSe non è dato nessun percorso, viene preso quello di avvio del programma.&#39;},
                        {&#39;short&#39;: &#39;g&#39;, &#39;full&#39;: &#39;gui&#39;, &#39;args&#39;: True, &#39;default&#39;: &#39;&#39;, &#39;help&#39;:
                         &#39;&#39;&#39;Avvia l\&#39;interfaccia web del centro di controllo solo con alcune sezioni.
I parametri possibili sono:
\tmanager\t  Creazione e gestione delle notifiche
\tpreview\t  Anteprima della notifica (funzione sperimentale)
\tlist\t  Informazioni e gestione dei Butlers collegati&#39;&#39;&#39;},
                        {&#39;short&#39;: &#39;n&#39;, &#39;full&#39;: &#39;no_gui&#39;, &#39;args&#39;: False, &#39;default&#39;: &#39;&#39;, &#39;help&#39;:
                         &#39;&#39;&#39;Non avvia l&#39;interfaccia web.
Il server rimane raggiungibile attraverso richieste REST.&#39;&#39;&#39;},
                        {&#39;short&#39;: &#39;p&#39;, &#39;full&#39;: &#39;passive&#39;, &#39;args&#39;: False, &#39;default&#39;: &#39;&#39;,
                         &#39;help&#39;: &#39;Ignora il buffer delle notifiche.&#39;}
                ]
                argsParser = ArgsParser(params)
                args = argsParser.parse()
                try:
                        self.configs = ConfigParser().load_configs(args[&#39;config&#39;])
                except FileNotFoundError as e:
                        log.critical(
                                &#39;Impossibile leggere il file di configurazione:\n{}&#39;.format(e.__str__()))
                        return
                except JSONDecodeError as e:
                        log.critical(
                                &#39;Errore nella decodifica del file di configurazione:\n{}&#39;.format(e.__str__()))
                        return

                Logger().start(**self.configs[&#39;logging&#39;])
                self.ipParser = IPParser()
                self.expireTime = self.configs[&#39;expireTime&#39;]
                self.protocol = self.configs[&#39;protocol&#39;]
                self.serverConf = self.configs[&#39;server&#39;]
                self.controlConf = self.configs[&#39;controlCenter&#39;]
                self.guiConf = self.configs[&#39;gui&#39;]
                self.testNotifData = &#39;&#39;

                self.addr = &#39;{}://{}:{}&#39;.format(self.protocol,
                                                                                self.serverConf[&#39;ip&#39;], self.serverConf[&#39;port&#39;])
                self.id = self.serverConf[&#39;id&#39;]
                log.info(&#39;Avvio del server su {}&#39;.format(self.addr))

                # avvio dell&#39;ascoltatore dei Butlers
                butlerCallbacks = {&#39;add_butler&#39;: self.add_butler,
                                         &#39;disconnect&#39;: self.disconnect_client,
                                         &#39;interacted&#39;: self.interacted, &#39;update_db_details&#39;: self.update_db_details,
                                         &#39;butler_exists&#39;: self.butler_exists}

                self.butlerApi = ButlerAPI(self.serverConf[&#39;ip&#39;], self.serverConf[&#39;port&#39;],
                                                         self.expireTime, self.configs[&#39;ssl&#39;], butlerCallbacks,
                                                         )
                threading.Thread(target=self.butlerApi.start_api, daemon=True).start()

                # imposta e avvia l&#39;API del centro di controllo
                controlCenterAddr = &#39;{}://{}:{}&#39;.format(
                        self.protocol, self.controlConf[&#39;ip&#39;], self.controlConf[&#39;port&#39;])
                self.dbHelper = DbHelper()
                self.dbHelper.login(**self.configs[&#34;database&#34;])

                controlCallbacks = {&#39;send_notif&#39;: self.send_notif, &#39;check_butlers&#39;: self.check_butlers,
                                          &#39;can_disconnect&#39;: self.can_disconnect, &#39;force_disconnect&#39;: self.force_disconnect,
                                          &#39;get_files&#39;: self.get_files_list, &#39;revoke&#39;: self.revoke,
                                          &#39;validate_credentials&#39;: self.validate_credentials,
                                          &#39;test_notif&#39;: self.test_notif,
                                          &#39;get_butler_details&#39;: self.get_butler_details,
                                          &#39;set_butler_details&#39;: self.set_butler_details,
                                          &#39;edit_butler&#39;: self.edit_butler, &#39;apply_standard_model&#39;: self.apply_standard_model}

                sections = args[&#39;gui&#39;].split(
                        &#39;,&#39;) if args[&#39;gui&#39;] != &#39;&#39; else self.guiConf[&#39;sections&#39;]

                self.controlCenterApi = ControlCenterAPI(self.controlConf[&#39;ip&#39;], self.controlConf[&#39;port&#39;],
                                                                                   self.configs[&#39;expireTime&#39;], self.configs[&#39;ssl&#39;], controlCallbacks,
                                                                                   self.dbHelper, self.configs[&#39;imagesPath&#39;], self.controlConf[&#39;previewPort&#39;],
                                                                                   &#39;{}://{}:{}&#39;.format(self.protocol, self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;]), sections)
                threading.Thread(target=self.controlCenterApi.start_api, daemon=True).start()

                # avvio del controllo del buffer
                if self.configs[&#39;bufferTimer&#39;] &gt;= 1 and not args[&#39;passive&#39;]:
                        threading.Thread(target=self.check_buffer, args=[
                                self.configs[&#39;bufferTimer&#39;]], daemon=True).start()

                # prepara l&#39;interfaccia grafica del server
                guiAddr = &#39;{}://{}:{}&#39;.format(
                        self.protocol, self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;])

                self.controlCenterGui = ControlCenterGUI(self.guiConf[&#39;ip&#39;], self.guiConf[&#39;port&#39;],
                                                                                   controlCenterAddr, self.configs[&#39;ssl&#39;], self.configs[&#39;gui&#39;][&#39;templatesPath&#39;], self.configs[&#39;gui&#39;][&#39;resPath&#39;])
                threading.Thread(target=self.controlCenterGui.start_api, daemon=True).start()

                # se necessario, apre una finestra del browser per la GUI
                if not args[&#39;no_gui&#39;]:
                        webbrowser.open(guiAddr, new=2, autoraise=False)

                notifBuilder = NotificationBuilder(
                        logoPath=self.configs[&#39;logoPath&#39;], testing=True)

                try:
                        while True:
                                if self.testNotifData != &#39;&#39;:
                                        log.warning(&#39;Test reale della notifica &#34;{}&#34;&#39;.format(
                                                self.testNotifData[&#39;name&#39;]))
                                        notifBuilder.interrupt = False
                                        notifBuilder.show_window(self.testNotifData)
                                        self.testNotifData = &#39;&#39;
                                sleep(self.TIMER)

                except KeyboardInterrupt:
                        sys.exit()</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.test_notif"><code class="name flex">
<span>def <span class="ident">test_notif</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Autoinvia una notifica per testarne unicamente lo stile.</p>
<p>:param data (dict): i dati della notifica da mostrare.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_notif(self, data):
        &#34;&#34;&#34;
        Autoinvia una notifica per testarne unicamente lo stile.
        
        :param data (dict): i dati della notifica da mostrare.
        &#34;&#34;&#34;
        self.testNotifData = self.parse_notif_data(data)</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.update_db_details"><code class="name flex">
<span>def <span class="ident">update_db_details</span></span>(<span>self, details)</span>
</code></dt>
<dd>
<div class="desc"><p>Aggiorna le informazioni ricevute dal Butler nel database.</p>
<p>:param details (dict): i dati da aggiornare.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_db_details(self, details):
        &#34;&#34;&#34;
        Aggiorna le informazioni ricevute dal Butler nel database.

        :param details (dict): i dati da aggiornare.
        &#34;&#34;&#34;
        self.dbHelper.upsert_details(details)</code></pre>
</details>
</dd>
<dt id="src.server.manager.Manager.validate_credentials"><code class="name flex">
<span>def <span class="ident">validate_credentials</span></span>(<span>self, user, password)</span>
</code></dt>
<dd>
<div class="desc"><p>Controlla che le credenziali passate corrispondano a quelle memorizzate
nel file di configurazione.
La pasword è salvata come SHA265.</p>
<p>:param user (str): il nome utente dell'amministratore.
:param password (str): la password dell'amministratore.</p>
<p>:return: True se le credenziali corrispondono.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_credentials(self, user, password):
        &#34;&#34;&#34;
        Controlla che le credenziali passate corrispondano a quelle memorizzate
        nel file di configurazione.
        La pasword è salvata come SHA265.
        
        :param user (str): il nome utente dell&#39;amministratore.
        :param password (str): la password dell&#39;amministratore.
        
        :return: True se le credenziali corrispondono.
        &#34;&#34;&#34;
        return user == self.configs[&#39;username&#39;] and hashlib.sha256(password.lower().encode(&#34;utf&#34;)).hexdigest() == self.configs[&#39;password&#39;].lower()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.server" href="index.html">src.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.server.manager.Manager" href="#src.server.manager.Manager">Manager</a></code></h4>
<ul class="">
<li><code><a title="src.server.manager.Manager.STANDARD_MODEL_MAC" href="#src.server.manager.Manager.STANDARD_MODEL_MAC">STANDARD_MODEL_MAC</a></code></li>
<li><code><a title="src.server.manager.Manager.TIMER" href="#src.server.manager.Manager.TIMER">TIMER</a></code></li>
<li><code><a title="src.server.manager.Manager.add_butler" href="#src.server.manager.Manager.add_butler">add_butler</a></code></li>
<li><code><a title="src.server.manager.Manager.addr_exists" href="#src.server.manager.Manager.addr_exists">addr_exists</a></code></li>
<li><code><a title="src.server.manager.Manager.apply_standard_model" href="#src.server.manager.Manager.apply_standard_model">apply_standard_model</a></code></li>
<li><code><a title="src.server.manager.Manager.butler_exists" href="#src.server.manager.Manager.butler_exists">butler_exists</a></code></li>
<li><code><a title="src.server.manager.Manager.butlers" href="#src.server.manager.Manager.butlers">butlers</a></code></li>
<li><code><a title="src.server.manager.Manager.can_disconnect" href="#src.server.manager.Manager.can_disconnect">can_disconnect</a></code></li>
<li><code><a title="src.server.manager.Manager.check_buffer" href="#src.server.manager.Manager.check_buffer">check_buffer</a></code></li>
<li><code><a title="src.server.manager.Manager.check_butlers" href="#src.server.manager.Manager.check_butlers">check_butlers</a></code></li>
<li><code><a title="src.server.manager.Manager.collMap" href="#src.server.manager.Manager.collMap">collMap</a></code></li>
<li><code><a title="src.server.manager.Manager.disconnect_client" href="#src.server.manager.Manager.disconnect_client">disconnect_client</a></code></li>
<li><code><a title="src.server.manager.Manager.edit_butler" href="#src.server.manager.Manager.edit_butler">edit_butler</a></code></li>
<li><code><a title="src.server.manager.Manager.force_disconnect" href="#src.server.manager.Manager.force_disconnect">force_disconnect</a></code></li>
<li><code><a title="src.server.manager.Manager.get_butler_details" href="#src.server.manager.Manager.get_butler_details">get_butler_details</a></code></li>
<li><code><a title="src.server.manager.Manager.get_file_data" href="#src.server.manager.Manager.get_file_data">get_file_data</a></code></li>
<li><code><a title="src.server.manager.Manager.get_files_list" href="#src.server.manager.Manager.get_files_list">get_files_list</a></code></li>
<li><code><a title="src.server.manager.Manager.interacted" href="#src.server.manager.Manager.interacted">interacted</a></code></li>
<li><code><a title="src.server.manager.Manager.interactions" href="#src.server.manager.Manager.interactions">interactions</a></code></li>
<li><code><a title="src.server.manager.Manager.parse_notif_data" href="#src.server.manager.Manager.parse_notif_data">parse_notif_data</a></code></li>
<li><code><a title="src.server.manager.Manager.revoke" href="#src.server.manager.Manager.revoke">revoke</a></code></li>
<li><code><a title="src.server.manager.Manager.send_notif" href="#src.server.manager.Manager.send_notif">send_notif</a></code></li>
<li><code><a title="src.server.manager.Manager.set_butler_details" href="#src.server.manager.Manager.set_butler_details">set_butler_details</a></code></li>
<li><code><a title="src.server.manager.Manager.start" href="#src.server.manager.Manager.start">start</a></code></li>
<li><code><a title="src.server.manager.Manager.test_notif" href="#src.server.manager.Manager.test_notif">test_notif</a></code></li>
<li><code><a title="src.server.manager.Manager.update_db_details" href="#src.server.manager.Manager.update_db_details">update_db_details</a></code></li>
<li><code><a title="src.server.manager.Manager.validate_credentials" href="#src.server.manager.Manager.validate_credentials">validate_credentials</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>