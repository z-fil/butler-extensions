<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.server.dbHelper API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.server.dbHelper</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pymongo import MongoClient
from datetime import datetime

from common import log

class DbHelper():
        &#34;&#34;&#34;
        Questa classe permette di stabilire una connessione al database MongoDB
        e di eseguire varie operazioni di base sui documenti delle notifiche,
        dei buffer e delle informazioni dei computers.
        Si occupa anche di mantenere l’integrità dei dati:
        in particolare dei riferimenti dal buffer alle notifiche e la coerenza
        tra le connessioni del modello.
        &#34;&#34;&#34;

        IP = 0
        PORT = 1
        
        def login(self, ip, port, serverTimeout=500, queryTimeout=1500):
                &#34;&#34;&#34;
                Stabilisce una connessione al database in base ai parametri
                salvando i riferimenti alle tabelle notification e buffer.
                
                :param ip (str): l&#39;ip del server MongoDB.
                :param port (int): la porta del server.
                &#34;&#34;&#34;
                connStr = &#39;mongodb://{}:{}&#39;.format(ip, port)
                client = MongoClient(
                        connStr, serverSelectionTimeoutMS=serverTimeout, connectTimeoutMS=queryTimeout)
                log.info(&#39;Connessione al database {}&#39;.format(connStr))
                db = client[&#34;butler&#34;]
                self.bufferColl = db[&#39;buffer&#39;]
                self.notifColl = db[&#39;notification&#39;]
                self.computerColl = db[&#39;computer&#39;]


        def get_notif(self, query={}, filter={}):
                &#34;&#34;&#34;
                Permette di ricavare una notifica in base ad una query.
                
                :param query (dict): la query in formato di dizionario.
                :return: il cursore per iterare i dati trovati.
                &#34;&#34;&#34;
                try:
                        return [notif for notif in self.notifColl.find(query, filter) if &#39;name&#39; not in notif or notif[&#39;name&#39;] != &#39;&#39;]
                except Exception as e:
                        self.log_db_error(e)
                return []


        def get_notif_id(self, name):
                &#34;&#34;&#34;
                Permette di ricavare l’id di una notifica in base al nome.
                
                :param name (str): il nome della notifica.
                :return: None se il nome non ha una corrispondenza, altrimenti l&#39;id trovato.
                &#34;&#34;&#34;
                try:
                        result = self.notifColl.find_one({&#39;name&#39;: name}, {&#39;_id&#39;: 1})
                except Exception as e:
                        self.log_db_error(e)
                        return None
                return None if result is None else result[&#39;_id&#39;]

        def get_notif_data(self, name):
                &#34;&#34;&#34;
                Permette di ricavare i dati di una notifica in base al nome
                
                :param name (str): il nome ricercato.
                
                :return: i dati della notifica, senza ID.
                &#34;&#34;&#34;
                result = []
                try:
                        result = self.notifColl.find_one({&#39;name&#39;: name}, {&#39;_id&#39;: 0})
                except Exception as e:
                        self.log_db_error(e)
                        return []
                return [] if result is None else result


        def upsert_notif(self, data):
                &#34;&#34;&#34;
                Aggiorna o crea la notifica in base al parametro data.
                
                :param data (dict): i nuovi dati nella notifica 
                :return: il documento della notifica modificata.
                &#34;&#34;&#34;
                try:
                        return self.notifColl.find_one_and_update(
                                {&#39;name&#39;: data[&#39;name&#39;]},
                                {&#39;$set&#39;: data}, upsert=True
                        ) if &#39;name&#39; in data else None
                except Exception as e:
                        self.log_db_error(e)
                return []

        def delete_notif(self, notifName):
                &#34;&#34;&#34;
                Cancella la notifica e tutti i buffer che ne fanno riferimento in base al nome.
                
                :param notifName (str): il nome della notifica da cancellare.
                :return: True se è stata eliminata una notifica, altrimenti False.
                &#34;&#34;&#34;
                try:
                        doc = self.notifColl.find_one_and_delete({&#39;name&#39;: notifName})
                        if doc is None:
                                log.warning(&#39;Eliminazione di &#34;{}&#34; fallita: il nome non è stato trovato nel database)&#39;.format(notifName))
                                return False
                        id = doc[&#39;_id&#39;]
                        self.delete_buffer({&#39;notification&#39;: id})
                        return True
                except Exception as e:
                        self.log_db_error(e)
                return False

        def get_buffer(self):
                &#34;&#34;&#34;
                Legge i buffer e unisce i dati in un array senza riferimenti ad ID.

                :return: i buffer con notifiche che vanno già consegnate.
                &#34;&#34;&#34;
                buffers = []
                try:
                        self.clean_buffer()
                        for b in self.bufferColl.find():
                                if str(b[&#39;deliveryStart&#39;]) &lt; (str(datetime.today())):
                                        buffers.append({
                                                &#39;_id&#39;: b[&#39;_id&#39;],
                                                &#39;notification&#39;: self.get_notif(
                                                        {&#39;_id&#39;: b[&#39;notification&#39;]},
                                                        {&#39;_id&#39;: 0, &#39;name&#39;: 1})[0][&#39;name&#39;],
                                                &#39;recipients&#39;: [r for r in b[&#39;recipients&#39;]],
                                                &#39;excluded&#39;: [e for e in b[&#39;excluded&#39;]]
                                        })
                except Exception as e:
                        self.log_db_error(e)
                return buffers

        def add_buffered_notif(self, notifName, recipients, deliveryStart=datetime.today()):
                &#34;&#34;&#34;
                Aggiunge un nuovo buffer per la notifica passata come parametro.

                :param notif_name (str): il nome della notifica per la quale creare il buffer.
                :param recipients (list): i destinatari ai quali andrà inviata la notifica
                :param deliveryStart (date, optional): . Defaults to datetime.today().

                :return: il risultato dell&#39;operazione di inserimento se valido, altrimenti False.
                &#34;&#34;&#34;
                try:
                        notifId = self.get_notif_id(notifName)
                        if notifId is None or len(recipients) == 0:
                                log.error(&#39;Aggiunta della notifica &#34;{}&#34; in un buffer fallita: il nome non è stato trovato nel database&#39;.format(notifName))
                                return False
                        # è sempre inserito un nuovo buffer, mai sovrascritto uno vecchio
                        return self.bufferColl.insert_one({
                                &#39;notification&#39;: notifId,
                                &#39;recipients&#39;: recipients,
                                &#39;excluded&#39;: [],
                                &#39;deliveryStart&#39;: deliveryStart
                        })
                except Exception as e:
                        self.log_db_error(e)
                return False

        def update_buffer(self, buffer):
                &#34;&#34;&#34;
                Aggiorna i destinatari di un buffer passato come parametro,
                o lo elimina se non ci sono più destinatari in sospeso da raggiungere.
                
                :param buffer (dict): il buffer dal quale sarà ricavato l&#39;id.
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                for addr in buffer[&#39;excluded&#39;]:
                        # rimouve dalla lista i destinatari raggiunti
                        if addr in buffer[&#39;recipients&#39;]:
                                buffer[&#39;recipients&#39;].remove(addr)
                try:
                        if len(buffer[&#39;recipients&#39;]) &gt; 0:
                                return self.bufferColl.find_one_and_update(
                                        {&#39;_id&#39;: buffer[&#39;_id&#39;]},
                                        {&#39;$set&#39;: {&#39;excluded&#39;: buffer[&#39;excluded&#39;],
                                                        &#39;recipients&#39;: buffer[&#39;recipients&#39;]}}
                                )
                        else:
                                return self.bufferColl.find_one_and_delete({&#39;_id&#39;: buffer[&#39;_id&#39;]})
                except Exception as e:
                        self.log_db_error(e)
                return None
        
        def delete_buffer(self, query):
                &#34;&#34;&#34;
                Cancella il buffer in base alla query.
                
                :param query (dict): la query sotto forma di dizionario.
                :return: il risultato dell&#39;operazione di eliminazione.
                &#34;&#34;&#34;
                try:
                        return self.bufferColl.delete_many(query).deleted_count
                except Exception as e:
                        self.log_db_error(e)
                return None

        def clean_buffer(self):
                &#34;&#34;&#34;
                Cerca i buffer con notifiche che non esistono più e li elimina.
                &#34;&#34;&#34;
                try:
                        for buffer in self.bufferColl.find({}, {&#39;notification&#39;: 1}):
                                if len(self.get_notif({&#39;_id&#39;: buffer[&#39;notification&#39;]})) == 0:
                                        self.delete_buffer({&#39;notification&#39;: buffer[&#39;notification&#39;]})
                except Exception as e:
                        self.log_db_error(e)

        def log_db_error(self, e):
                &#34;&#34;&#34;
                Aggiunge ai log il messaggio dell&#39;eccezione sollevata.
                
                :param e (obj): un oggetto con le informazioni sull&#39;errore.
                &#34;&#34;&#34;
                log.error(&#39;Timeout nella richiesta al database: {}&#39;.format(e))


        &#34;&#34;&#34;
        #####################################
        Funzioni aggiuntive butler-extensions
        #####################################
        &#34;&#34;&#34;
        
        def get_computer_data(self, mac):
                &#34;&#34;&#34;
                Legge dal database i dati di un computer.

                :param mac (str): l&#39;indirizzo MAC del computer.

                :return: i dati del computer.
                &#34;&#34;&#34;
                result = {}
                try:
                        result = self.computerColl.find_one({&#39;mac&#39;: mac}, {&#39;_id&#39;: 0, &#39;modules&#39;: 1, &#39;model&#39;: 1, &#39;phase&#39;: 1, &#39;inventory&#39;: 1})
                except Exception as e:
                        self.log_db_error(e)
                return {} if result is None else result

        def upsert_details(self, data):
                &#34;&#34;&#34;
                Analizza i dati passati e li inserisce o li aggiorna nel database.

                :param data (dict): il dizionario con i vari elementi da inserire.
                &#34;&#34;&#34;
                try:
                        if data is None or &#39;mac&#39; not in data:
                                return
                        # verifica i dati per ogni attributo, dato che
                        # necessitano di essere trattati in modo differente tra loro
                        for attr in data:
                                # il mac è sempre uguale; non va modificato
                                if attr == &#39;mac&#39;:
                                        continue
                                elif attr == &#39;model&#39;:
                                        # se è una lista, va verificato singolarmente ogni elemento
                                        if type(data[attr]) == list:
                                                for e in data[attr]:
                                                        self.update_conn(data[&#39;mac&#39;], e)
                                        else:
                                                self.update_conn(data[&#39;mac&#39;], data[attr])
                                else:
                                        # i dizionari necessitano di una chiave ulteriore
                                        if type(data[attr]) == dict and data[attr] != {}:
                                                for key in list(data[attr].keys()):
                                                        self.update_value(data[&#39;mac&#39;], data[attr][key], attr+&#39;.&#39;+key)
                                        else:
                                                self.update_value(data[&#39;mac&#39;], data[attr], attr)
                except Exception as e:
                        self.log_db_error(e)
                
        def update_conn(self, mac, conn):
                &#34;&#34;&#34;
                Inserisce o aggiorna una connessione del modello.

                :param mac (str): l&#39;indirizzo MAC del computer.
                :param conn (dict): i dati da inserire.
                &#34;&#34;&#34;
                # &#34;$elemMatch&#34; trova l&#39;elemento al quale &#34;model.$&#34; farà riferimento 
                result = self.computerColl.find_one_and_update(
                        {&#39;mac&#39;: mac, &#39;model&#39;: {&#39;$elemMatch&#39;: {
                                &#39;proc&#39;: conn[&#39;proc&#39;],
                                &#39;$or&#39;: [ 
                                        {&#39;$and&#39;: [
                                                {&#39;dest.{}&#39;.format(self.IP): &#39;&#39;},
                                                {&#39;dest.{}&#39;.format(self.PORT): &#39;&#39;},
                                                {&#39;dest.{}&#39;.format(self.IP): conn[&#39;dest&#39;][self.IP]},
                                                {&#39;dest.{}&#39;.format(self.PORT): conn[&#39;dest&#39;][self.PORT]},
                                                {&#39;source.{}&#39;.format(self.IP): conn[&#39;source&#39;][self.IP]},
                                                {&#39;source.{}&#39;.format(self.PORT): conn[&#39;source&#39;][self.PORT]},
                                        ]},
                                        {&#39;$and&#39;: [
                                                {&#39;dest.{}&#39;.format(self.IP): {&#39;$ne&#39;: &#39;&#39;}},
                                                {&#39;dest.{}&#39;.format(self.PORT): {&#39;$ne&#39;: &#39;&#39;}},
                                                {&#39;dest.{}&#39;.format(self.IP): conn[&#39;dest&#39;][self.IP]},
                                                {&#39;dest.{}&#39;.format(self.PORT): conn[&#39;dest&#39;][self.PORT]},
                                                {&#39;source.{}&#39;.format(self.IP): conn[&#39;source&#39;][self.IP]}
                                        ]}
                                ]
                        }}},
                        {&#39;$set&#39;: {&#39;model.$&#39;: conn} }
                )

                # se la connessione non è presente, la aggiunge:
                # &#34;upsert&#34; non funziona con la condizione di $elemMatch
                if result is None:
                        self.computerColl.find_one_and_update(
                                {&#39;mac&#39;: mac}, {&#39;$addToSet&#39;: {&#39;model&#39;: conn}})

        def update_value(self, mac, value, selector):
                &#34;&#34;&#34;
                Inserisce o aggiorna un dato generico nel database.

                :param mac (str): l&#39;indirizzo MAC del computer.
                :param value (obj): il dato da inserire.
                :param selector (str): la chiave del dato da aggiornare.
                &#34;&#34;&#34;
                self.computerColl.find_one_and_update({&#39;mac&#39;: mac},
                        {&#39;$set&#39;: {selector: value}}, upsert=True)

        &#34;&#34;&#34;
        ##########################################
        Fine funzioni aggiuntive butler-extensions
        ##########################################
        &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.server.dbHelper.DbHelper"><code class="flex name class">
<span>class <span class="ident">DbHelper</span></span>
</code></dt>
<dd>
<div class="desc"><p>Questa classe permette di stabilire una connessione al database MongoDB
e di eseguire varie operazioni di base sui documenti delle notifiche,
dei buffer e delle informazioni dei computers.
Si occupa anche di mantenere l’integrità dei dati:
in particolare dei riferimenti dal buffer alle notifiche e la coerenza
tra le connessioni del modello.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DbHelper():
        &#34;&#34;&#34;
        Questa classe permette di stabilire una connessione al database MongoDB
        e di eseguire varie operazioni di base sui documenti delle notifiche,
        dei buffer e delle informazioni dei computers.
        Si occupa anche di mantenere l’integrità dei dati:
        in particolare dei riferimenti dal buffer alle notifiche e la coerenza
        tra le connessioni del modello.
        &#34;&#34;&#34;

        IP = 0
        PORT = 1
        
        def login(self, ip, port, serverTimeout=500, queryTimeout=1500):
                &#34;&#34;&#34;
                Stabilisce una connessione al database in base ai parametri
                salvando i riferimenti alle tabelle notification e buffer.
                
                :param ip (str): l&#39;ip del server MongoDB.
                :param port (int): la porta del server.
                &#34;&#34;&#34;
                connStr = &#39;mongodb://{}:{}&#39;.format(ip, port)
                client = MongoClient(
                        connStr, serverSelectionTimeoutMS=serverTimeout, connectTimeoutMS=queryTimeout)
                log.info(&#39;Connessione al database {}&#39;.format(connStr))
                db = client[&#34;butler&#34;]
                self.bufferColl = db[&#39;buffer&#39;]
                self.notifColl = db[&#39;notification&#39;]
                self.computerColl = db[&#39;computer&#39;]


        def get_notif(self, query={}, filter={}):
                &#34;&#34;&#34;
                Permette di ricavare una notifica in base ad una query.
                
                :param query (dict): la query in formato di dizionario.
                :return: il cursore per iterare i dati trovati.
                &#34;&#34;&#34;
                try:
                        return [notif for notif in self.notifColl.find(query, filter) if &#39;name&#39; not in notif or notif[&#39;name&#39;] != &#39;&#39;]
                except Exception as e:
                        self.log_db_error(e)
                return []


        def get_notif_id(self, name):
                &#34;&#34;&#34;
                Permette di ricavare l’id di una notifica in base al nome.
                
                :param name (str): il nome della notifica.
                :return: None se il nome non ha una corrispondenza, altrimenti l&#39;id trovato.
                &#34;&#34;&#34;
                try:
                        result = self.notifColl.find_one({&#39;name&#39;: name}, {&#39;_id&#39;: 1})
                except Exception as e:
                        self.log_db_error(e)
                        return None
                return None if result is None else result[&#39;_id&#39;]

        def get_notif_data(self, name):
                &#34;&#34;&#34;
                Permette di ricavare i dati di una notifica in base al nome
                
                :param name (str): il nome ricercato.
                
                :return: i dati della notifica, senza ID.
                &#34;&#34;&#34;
                result = []
                try:
                        result = self.notifColl.find_one({&#39;name&#39;: name}, {&#39;_id&#39;: 0})
                except Exception as e:
                        self.log_db_error(e)
                        return []
                return [] if result is None else result


        def upsert_notif(self, data):
                &#34;&#34;&#34;
                Aggiorna o crea la notifica in base al parametro data.
                
                :param data (dict): i nuovi dati nella notifica 
                :return: il documento della notifica modificata.
                &#34;&#34;&#34;
                try:
                        return self.notifColl.find_one_and_update(
                                {&#39;name&#39;: data[&#39;name&#39;]},
                                {&#39;$set&#39;: data}, upsert=True
                        ) if &#39;name&#39; in data else None
                except Exception as e:
                        self.log_db_error(e)
                return []

        def delete_notif(self, notifName):
                &#34;&#34;&#34;
                Cancella la notifica e tutti i buffer che ne fanno riferimento in base al nome.
                
                :param notifName (str): il nome della notifica da cancellare.
                :return: True se è stata eliminata una notifica, altrimenti False.
                &#34;&#34;&#34;
                try:
                        doc = self.notifColl.find_one_and_delete({&#39;name&#39;: notifName})
                        if doc is None:
                                log.warning(&#39;Eliminazione di &#34;{}&#34; fallita: il nome non è stato trovato nel database)&#39;.format(notifName))
                                return False
                        id = doc[&#39;_id&#39;]
                        self.delete_buffer({&#39;notification&#39;: id})
                        return True
                except Exception as e:
                        self.log_db_error(e)
                return False

        def get_buffer(self):
                &#34;&#34;&#34;
                Legge i buffer e unisce i dati in un array senza riferimenti ad ID.

                :return: i buffer con notifiche che vanno già consegnate.
                &#34;&#34;&#34;
                buffers = []
                try:
                        self.clean_buffer()
                        for b in self.bufferColl.find():
                                if str(b[&#39;deliveryStart&#39;]) &lt; (str(datetime.today())):
                                        buffers.append({
                                                &#39;_id&#39;: b[&#39;_id&#39;],
                                                &#39;notification&#39;: self.get_notif(
                                                        {&#39;_id&#39;: b[&#39;notification&#39;]},
                                                        {&#39;_id&#39;: 0, &#39;name&#39;: 1})[0][&#39;name&#39;],
                                                &#39;recipients&#39;: [r for r in b[&#39;recipients&#39;]],
                                                &#39;excluded&#39;: [e for e in b[&#39;excluded&#39;]]
                                        })
                except Exception as e:
                        self.log_db_error(e)
                return buffers

        def add_buffered_notif(self, notifName, recipients, deliveryStart=datetime.today()):
                &#34;&#34;&#34;
                Aggiunge un nuovo buffer per la notifica passata come parametro.

                :param notif_name (str): il nome della notifica per la quale creare il buffer.
                :param recipients (list): i destinatari ai quali andrà inviata la notifica
                :param deliveryStart (date, optional): . Defaults to datetime.today().

                :return: il risultato dell&#39;operazione di inserimento se valido, altrimenti False.
                &#34;&#34;&#34;
                try:
                        notifId = self.get_notif_id(notifName)
                        if notifId is None or len(recipients) == 0:
                                log.error(&#39;Aggiunta della notifica &#34;{}&#34; in un buffer fallita: il nome non è stato trovato nel database&#39;.format(notifName))
                                return False
                        # è sempre inserito un nuovo buffer, mai sovrascritto uno vecchio
                        return self.bufferColl.insert_one({
                                &#39;notification&#39;: notifId,
                                &#39;recipients&#39;: recipients,
                                &#39;excluded&#39;: [],
                                &#39;deliveryStart&#39;: deliveryStart
                        })
                except Exception as e:
                        self.log_db_error(e)
                return False

        def update_buffer(self, buffer):
                &#34;&#34;&#34;
                Aggiorna i destinatari di un buffer passato come parametro,
                o lo elimina se non ci sono più destinatari in sospeso da raggiungere.
                
                :param buffer (dict): il buffer dal quale sarà ricavato l&#39;id.
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                for addr in buffer[&#39;excluded&#39;]:
                        # rimouve dalla lista i destinatari raggiunti
                        if addr in buffer[&#39;recipients&#39;]:
                                buffer[&#39;recipients&#39;].remove(addr)
                try:
                        if len(buffer[&#39;recipients&#39;]) &gt; 0:
                                return self.bufferColl.find_one_and_update(
                                        {&#39;_id&#39;: buffer[&#39;_id&#39;]},
                                        {&#39;$set&#39;: {&#39;excluded&#39;: buffer[&#39;excluded&#39;],
                                                        &#39;recipients&#39;: buffer[&#39;recipients&#39;]}}
                                )
                        else:
                                return self.bufferColl.find_one_and_delete({&#39;_id&#39;: buffer[&#39;_id&#39;]})
                except Exception as e:
                        self.log_db_error(e)
                return None
        
        def delete_buffer(self, query):
                &#34;&#34;&#34;
                Cancella il buffer in base alla query.
                
                :param query (dict): la query sotto forma di dizionario.
                :return: il risultato dell&#39;operazione di eliminazione.
                &#34;&#34;&#34;
                try:
                        return self.bufferColl.delete_many(query).deleted_count
                except Exception as e:
                        self.log_db_error(e)
                return None

        def clean_buffer(self):
                &#34;&#34;&#34;
                Cerca i buffer con notifiche che non esistono più e li elimina.
                &#34;&#34;&#34;
                try:
                        for buffer in self.bufferColl.find({}, {&#39;notification&#39;: 1}):
                                if len(self.get_notif({&#39;_id&#39;: buffer[&#39;notification&#39;]})) == 0:
                                        self.delete_buffer({&#39;notification&#39;: buffer[&#39;notification&#39;]})
                except Exception as e:
                        self.log_db_error(e)

        def log_db_error(self, e):
                &#34;&#34;&#34;
                Aggiunge ai log il messaggio dell&#39;eccezione sollevata.
                
                :param e (obj): un oggetto con le informazioni sull&#39;errore.
                &#34;&#34;&#34;
                log.error(&#39;Timeout nella richiesta al database: {}&#39;.format(e))


        &#34;&#34;&#34;
        #####################################
        Funzioni aggiuntive butler-extensions
        #####################################
        &#34;&#34;&#34;
        
        def get_computer_data(self, mac):
                &#34;&#34;&#34;
                Legge dal database i dati di un computer.

                :param mac (str): l&#39;indirizzo MAC del computer.

                :return: i dati del computer.
                &#34;&#34;&#34;
                result = {}
                try:
                        result = self.computerColl.find_one({&#39;mac&#39;: mac}, {&#39;_id&#39;: 0, &#39;modules&#39;: 1, &#39;model&#39;: 1, &#39;phase&#39;: 1, &#39;inventory&#39;: 1})
                except Exception as e:
                        self.log_db_error(e)
                return {} if result is None else result

        def upsert_details(self, data):
                &#34;&#34;&#34;
                Analizza i dati passati e li inserisce o li aggiorna nel database.

                :param data (dict): il dizionario con i vari elementi da inserire.
                &#34;&#34;&#34;
                try:
                        if data is None or &#39;mac&#39; not in data:
                                return
                        # verifica i dati per ogni attributo, dato che
                        # necessitano di essere trattati in modo differente tra loro
                        for attr in data:
                                # il mac è sempre uguale; non va modificato
                                if attr == &#39;mac&#39;:
                                        continue
                                elif attr == &#39;model&#39;:
                                        # se è una lista, va verificato singolarmente ogni elemento
                                        if type(data[attr]) == list:
                                                for e in data[attr]:
                                                        self.update_conn(data[&#39;mac&#39;], e)
                                        else:
                                                self.update_conn(data[&#39;mac&#39;], data[attr])
                                else:
                                        # i dizionari necessitano di una chiave ulteriore
                                        if type(data[attr]) == dict and data[attr] != {}:
                                                for key in list(data[attr].keys()):
                                                        self.update_value(data[&#39;mac&#39;], data[attr][key], attr+&#39;.&#39;+key)
                                        else:
                                                self.update_value(data[&#39;mac&#39;], data[attr], attr)
                except Exception as e:
                        self.log_db_error(e)
                
        def update_conn(self, mac, conn):
                &#34;&#34;&#34;
                Inserisce o aggiorna una connessione del modello.

                :param mac (str): l&#39;indirizzo MAC del computer.
                :param conn (dict): i dati da inserire.
                &#34;&#34;&#34;
                # &#34;$elemMatch&#34; trova l&#39;elemento al quale &#34;model.$&#34; farà riferimento 
                result = self.computerColl.find_one_and_update(
                        {&#39;mac&#39;: mac, &#39;model&#39;: {&#39;$elemMatch&#39;: {
                                &#39;proc&#39;: conn[&#39;proc&#39;],
                                &#39;$or&#39;: [ 
                                        {&#39;$and&#39;: [
                                                {&#39;dest.{}&#39;.format(self.IP): &#39;&#39;},
                                                {&#39;dest.{}&#39;.format(self.PORT): &#39;&#39;},
                                                {&#39;dest.{}&#39;.format(self.IP): conn[&#39;dest&#39;][self.IP]},
                                                {&#39;dest.{}&#39;.format(self.PORT): conn[&#39;dest&#39;][self.PORT]},
                                                {&#39;source.{}&#39;.format(self.IP): conn[&#39;source&#39;][self.IP]},
                                                {&#39;source.{}&#39;.format(self.PORT): conn[&#39;source&#39;][self.PORT]},
                                        ]},
                                        {&#39;$and&#39;: [
                                                {&#39;dest.{}&#39;.format(self.IP): {&#39;$ne&#39;: &#39;&#39;}},
                                                {&#39;dest.{}&#39;.format(self.PORT): {&#39;$ne&#39;: &#39;&#39;}},
                                                {&#39;dest.{}&#39;.format(self.IP): conn[&#39;dest&#39;][self.IP]},
                                                {&#39;dest.{}&#39;.format(self.PORT): conn[&#39;dest&#39;][self.PORT]},
                                                {&#39;source.{}&#39;.format(self.IP): conn[&#39;source&#39;][self.IP]}
                                        ]}
                                ]
                        }}},
                        {&#39;$set&#39;: {&#39;model.$&#39;: conn} }
                )

                # se la connessione non è presente, la aggiunge:
                # &#34;upsert&#34; non funziona con la condizione di $elemMatch
                if result is None:
                        self.computerColl.find_one_and_update(
                                {&#39;mac&#39;: mac}, {&#39;$addToSet&#39;: {&#39;model&#39;: conn}})

        def update_value(self, mac, value, selector):
                &#34;&#34;&#34;
                Inserisce o aggiorna un dato generico nel database.

                :param mac (str): l&#39;indirizzo MAC del computer.
                :param value (obj): il dato da inserire.
                :param selector (str): la chiave del dato da aggiornare.
                &#34;&#34;&#34;
                self.computerColl.find_one_and_update({&#39;mac&#39;: mac},
                        {&#39;$set&#39;: {selector: value}}, upsert=True)

        &#34;&#34;&#34;
        ##########################################
        Fine funzioni aggiuntive butler-extensions
        ##########################################
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.server.dbHelper.DbHelper.IP"><code class="name">var <span class="ident">IP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.server.dbHelper.DbHelper.PORT"><code class="name">var <span class="ident">PORT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.server.dbHelper.DbHelper.add_buffered_notif"><code class="name flex">
<span>def <span class="ident">add_buffered_notif</span></span>(<span>self, notifName, recipients, deliveryStart=datetime.datetime(2021, 5, 26, 14, 27, 22, 920801))</span>
</code></dt>
<dd>
<div class="desc"><p>Aggiunge un nuovo buffer per la notifica passata come parametro.</p>
<p>:param notif_name (str): il nome della notifica per la quale creare il buffer.
:param recipients (list): i destinatari ai quali andrà inviata la notifica
:param deliveryStart (date, optional): . Defaults to datetime.today().</p>
<p>:return: il risultato dell'operazione di inserimento se valido, altrimenti False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_buffered_notif(self, notifName, recipients, deliveryStart=datetime.today()):
        &#34;&#34;&#34;
        Aggiunge un nuovo buffer per la notifica passata come parametro.

        :param notif_name (str): il nome della notifica per la quale creare il buffer.
        :param recipients (list): i destinatari ai quali andrà inviata la notifica
        :param deliveryStart (date, optional): . Defaults to datetime.today().

        :return: il risultato dell&#39;operazione di inserimento se valido, altrimenti False.
        &#34;&#34;&#34;
        try:
                notifId = self.get_notif_id(notifName)
                if notifId is None or len(recipients) == 0:
                        log.error(&#39;Aggiunta della notifica &#34;{}&#34; in un buffer fallita: il nome non è stato trovato nel database&#39;.format(notifName))
                        return False
                # è sempre inserito un nuovo buffer, mai sovrascritto uno vecchio
                return self.bufferColl.insert_one({
                        &#39;notification&#39;: notifId,
                        &#39;recipients&#39;: recipients,
                        &#39;excluded&#39;: [],
                        &#39;deliveryStart&#39;: deliveryStart
                })
        except Exception as e:
                self.log_db_error(e)
        return False</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.clean_buffer"><code class="name flex">
<span>def <span class="ident">clean_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cerca i buffer con notifiche che non esistono più e li elimina.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_buffer(self):
        &#34;&#34;&#34;
        Cerca i buffer con notifiche che non esistono più e li elimina.
        &#34;&#34;&#34;
        try:
                for buffer in self.bufferColl.find({}, {&#39;notification&#39;: 1}):
                        if len(self.get_notif({&#39;_id&#39;: buffer[&#39;notification&#39;]})) == 0:
                                self.delete_buffer({&#39;notification&#39;: buffer[&#39;notification&#39;]})
        except Exception as e:
                self.log_db_error(e)</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.delete_buffer"><code class="name flex">
<span>def <span class="ident">delete_buffer</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancella il buffer in base alla query.</p>
<p>:param query (dict): la query sotto forma di dizionario.
:return: il risultato dell'operazione di eliminazione.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_buffer(self, query):
        &#34;&#34;&#34;
        Cancella il buffer in base alla query.
        
        :param query (dict): la query sotto forma di dizionario.
        :return: il risultato dell&#39;operazione di eliminazione.
        &#34;&#34;&#34;
        try:
                return self.bufferColl.delete_many(query).deleted_count
        except Exception as e:
                self.log_db_error(e)
        return None</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.delete_notif"><code class="name flex">
<span>def <span class="ident">delete_notif</span></span>(<span>self, notifName)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancella la notifica e tutti i buffer che ne fanno riferimento in base al nome.</p>
<p>:param notifName (str): il nome della notifica da cancellare.
:return: True se è stata eliminata una notifica, altrimenti False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_notif(self, notifName):
        &#34;&#34;&#34;
        Cancella la notifica e tutti i buffer che ne fanno riferimento in base al nome.
        
        :param notifName (str): il nome della notifica da cancellare.
        :return: True se è stata eliminata una notifica, altrimenti False.
        &#34;&#34;&#34;
        try:
                doc = self.notifColl.find_one_and_delete({&#39;name&#39;: notifName})
                if doc is None:
                        log.warning(&#39;Eliminazione di &#34;{}&#34; fallita: il nome non è stato trovato nel database)&#39;.format(notifName))
                        return False
                id = doc[&#39;_id&#39;]
                self.delete_buffer({&#39;notification&#39;: id})
                return True
        except Exception as e:
                self.log_db_error(e)
        return False</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.get_buffer"><code class="name flex">
<span>def <span class="ident">get_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Legge i buffer e unisce i dati in un array senza riferimenti ad ID.</p>
<p>:return: i buffer con notifiche che vanno già consegnate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buffer(self):
        &#34;&#34;&#34;
        Legge i buffer e unisce i dati in un array senza riferimenti ad ID.

        :return: i buffer con notifiche che vanno già consegnate.
        &#34;&#34;&#34;
        buffers = []
        try:
                self.clean_buffer()
                for b in self.bufferColl.find():
                        if str(b[&#39;deliveryStart&#39;]) &lt; (str(datetime.today())):
                                buffers.append({
                                        &#39;_id&#39;: b[&#39;_id&#39;],
                                        &#39;notification&#39;: self.get_notif(
                                                {&#39;_id&#39;: b[&#39;notification&#39;]},
                                                {&#39;_id&#39;: 0, &#39;name&#39;: 1})[0][&#39;name&#39;],
                                        &#39;recipients&#39;: [r for r in b[&#39;recipients&#39;]],
                                        &#39;excluded&#39;: [e for e in b[&#39;excluded&#39;]]
                                })
        except Exception as e:
                self.log_db_error(e)
        return buffers</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.get_computer_data"><code class="name flex">
<span>def <span class="ident">get_computer_data</span></span>(<span>self, mac)</span>
</code></dt>
<dd>
<div class="desc"><p>Legge dal database i dati di un computer.</p>
<p>:param mac (str): l'indirizzo MAC del computer.</p>
<p>:return: i dati del computer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_computer_data(self, mac):
        &#34;&#34;&#34;
        Legge dal database i dati di un computer.

        :param mac (str): l&#39;indirizzo MAC del computer.

        :return: i dati del computer.
        &#34;&#34;&#34;
        result = {}
        try:
                result = self.computerColl.find_one({&#39;mac&#39;: mac}, {&#39;_id&#39;: 0, &#39;modules&#39;: 1, &#39;model&#39;: 1, &#39;phase&#39;: 1, &#39;inventory&#39;: 1})
        except Exception as e:
                self.log_db_error(e)
        return {} if result is None else result</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.get_notif"><code class="name flex">
<span>def <span class="ident">get_notif</span></span>(<span>self, query={}, filter={})</span>
</code></dt>
<dd>
<div class="desc"><p>Permette di ricavare una notifica in base ad una query.</p>
<p>:param query (dict): la query in formato di dizionario.
:return: il cursore per iterare i dati trovati.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_notif(self, query={}, filter={}):
        &#34;&#34;&#34;
        Permette di ricavare una notifica in base ad una query.
        
        :param query (dict): la query in formato di dizionario.
        :return: il cursore per iterare i dati trovati.
        &#34;&#34;&#34;
        try:
                return [notif for notif in self.notifColl.find(query, filter) if &#39;name&#39; not in notif or notif[&#39;name&#39;] != &#39;&#39;]
        except Exception as e:
                self.log_db_error(e)
        return []</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.get_notif_data"><code class="name flex">
<span>def <span class="ident">get_notif_data</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Permette di ricavare i dati di una notifica in base al nome</p>
<p>:param name (str): il nome ricercato.</p>
<p>:return: i dati della notifica, senza ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_notif_data(self, name):
        &#34;&#34;&#34;
        Permette di ricavare i dati di una notifica in base al nome
        
        :param name (str): il nome ricercato.
        
        :return: i dati della notifica, senza ID.
        &#34;&#34;&#34;
        result = []
        try:
                result = self.notifColl.find_one({&#39;name&#39;: name}, {&#39;_id&#39;: 0})
        except Exception as e:
                self.log_db_error(e)
                return []
        return [] if result is None else result</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.get_notif_id"><code class="name flex">
<span>def <span class="ident">get_notif_id</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Permette di ricavare l’id di una notifica in base al nome.</p>
<p>:param name (str): il nome della notifica.
:return: None se il nome non ha una corrispondenza, altrimenti l'id trovato.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_notif_id(self, name):
        &#34;&#34;&#34;
        Permette di ricavare l’id di una notifica in base al nome.
        
        :param name (str): il nome della notifica.
        :return: None se il nome non ha una corrispondenza, altrimenti l&#39;id trovato.
        &#34;&#34;&#34;
        try:
                result = self.notifColl.find_one({&#39;name&#39;: name}, {&#39;_id&#39;: 1})
        except Exception as e:
                self.log_db_error(e)
                return None
        return None if result is None else result[&#39;_id&#39;]</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.log_db_error"><code class="name flex">
<span>def <span class="ident">log_db_error</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<div class="desc"><p>Aggiunge ai log il messaggio dell'eccezione sollevata.</p>
<p>:param e (obj): un oggetto con le informazioni sull'errore.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_db_error(self, e):
        &#34;&#34;&#34;
        Aggiunge ai log il messaggio dell&#39;eccezione sollevata.
        
        :param e (obj): un oggetto con le informazioni sull&#39;errore.
        &#34;&#34;&#34;
        log.error(&#39;Timeout nella richiesta al database: {}&#39;.format(e))</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self, ip, port, serverTimeout=500, queryTimeout=1500)</span>
</code></dt>
<dd>
<div class="desc"><p>Stabilisce una connessione al database in base ai parametri
salvando i riferimenti alle tabelle notification e buffer.</p>
<p>:param ip (str): l'ip del server MongoDB.
:param port (int): la porta del server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login(self, ip, port, serverTimeout=500, queryTimeout=1500):
        &#34;&#34;&#34;
        Stabilisce una connessione al database in base ai parametri
        salvando i riferimenti alle tabelle notification e buffer.
        
        :param ip (str): l&#39;ip del server MongoDB.
        :param port (int): la porta del server.
        &#34;&#34;&#34;
        connStr = &#39;mongodb://{}:{}&#39;.format(ip, port)
        client = MongoClient(
                connStr, serverSelectionTimeoutMS=serverTimeout, connectTimeoutMS=queryTimeout)
        log.info(&#39;Connessione al database {}&#39;.format(connStr))
        db = client[&#34;butler&#34;]
        self.bufferColl = db[&#39;buffer&#39;]
        self.notifColl = db[&#39;notification&#39;]
        self.computerColl = db[&#39;computer&#39;]</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.update_buffer"><code class="name flex">
<span>def <span class="ident">update_buffer</span></span>(<span>self, buffer)</span>
</code></dt>
<dd>
<div class="desc"><p>Aggiorna i destinatari di un buffer passato come parametro,
o lo elimina se non ci sono più destinatari in sospeso da raggiungere.</p>
<p>:param buffer (dict): il buffer dal quale sarà ricavato l'id.
:return: il risultato dell'operazione.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_buffer(self, buffer):
        &#34;&#34;&#34;
        Aggiorna i destinatari di un buffer passato come parametro,
        o lo elimina se non ci sono più destinatari in sospeso da raggiungere.
        
        :param buffer (dict): il buffer dal quale sarà ricavato l&#39;id.
        :return: il risultato dell&#39;operazione.
        &#34;&#34;&#34;
        for addr in buffer[&#39;excluded&#39;]:
                # rimouve dalla lista i destinatari raggiunti
                if addr in buffer[&#39;recipients&#39;]:
                        buffer[&#39;recipients&#39;].remove(addr)
        try:
                if len(buffer[&#39;recipients&#39;]) &gt; 0:
                        return self.bufferColl.find_one_and_update(
                                {&#39;_id&#39;: buffer[&#39;_id&#39;]},
                                {&#39;$set&#39;: {&#39;excluded&#39;: buffer[&#39;excluded&#39;],
                                                &#39;recipients&#39;: buffer[&#39;recipients&#39;]}}
                        )
                else:
                        return self.bufferColl.find_one_and_delete({&#39;_id&#39;: buffer[&#39;_id&#39;]})
        except Exception as e:
                self.log_db_error(e)
        return None</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.update_conn"><code class="name flex">
<span>def <span class="ident">update_conn</span></span>(<span>self, mac, conn)</span>
</code></dt>
<dd>
<div class="desc"><p>Inserisce o aggiorna una connessione del modello.</p>
<p>:param mac (str): l'indirizzo MAC del computer.
:param conn (dict): i dati da inserire.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_conn(self, mac, conn):
        &#34;&#34;&#34;
        Inserisce o aggiorna una connessione del modello.

        :param mac (str): l&#39;indirizzo MAC del computer.
        :param conn (dict): i dati da inserire.
        &#34;&#34;&#34;
        # &#34;$elemMatch&#34; trova l&#39;elemento al quale &#34;model.$&#34; farà riferimento 
        result = self.computerColl.find_one_and_update(
                {&#39;mac&#39;: mac, &#39;model&#39;: {&#39;$elemMatch&#39;: {
                        &#39;proc&#39;: conn[&#39;proc&#39;],
                        &#39;$or&#39;: [ 
                                {&#39;$and&#39;: [
                                        {&#39;dest.{}&#39;.format(self.IP): &#39;&#39;},
                                        {&#39;dest.{}&#39;.format(self.PORT): &#39;&#39;},
                                        {&#39;dest.{}&#39;.format(self.IP): conn[&#39;dest&#39;][self.IP]},
                                        {&#39;dest.{}&#39;.format(self.PORT): conn[&#39;dest&#39;][self.PORT]},
                                        {&#39;source.{}&#39;.format(self.IP): conn[&#39;source&#39;][self.IP]},
                                        {&#39;source.{}&#39;.format(self.PORT): conn[&#39;source&#39;][self.PORT]},
                                ]},
                                {&#39;$and&#39;: [
                                        {&#39;dest.{}&#39;.format(self.IP): {&#39;$ne&#39;: &#39;&#39;}},
                                        {&#39;dest.{}&#39;.format(self.PORT): {&#39;$ne&#39;: &#39;&#39;}},
                                        {&#39;dest.{}&#39;.format(self.IP): conn[&#39;dest&#39;][self.IP]},
                                        {&#39;dest.{}&#39;.format(self.PORT): conn[&#39;dest&#39;][self.PORT]},
                                        {&#39;source.{}&#39;.format(self.IP): conn[&#39;source&#39;][self.IP]}
                                ]}
                        ]
                }}},
                {&#39;$set&#39;: {&#39;model.$&#39;: conn} }
        )

        # se la connessione non è presente, la aggiunge:
        # &#34;upsert&#34; non funziona con la condizione di $elemMatch
        if result is None:
                self.computerColl.find_one_and_update(
                        {&#39;mac&#39;: mac}, {&#39;$addToSet&#39;: {&#39;model&#39;: conn}})</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.update_value"><code class="name flex">
<span>def <span class="ident">update_value</span></span>(<span>self, mac, value, selector)</span>
</code></dt>
<dd>
<div class="desc"><p>Inserisce o aggiorna un dato generico nel database.</p>
<p>:param mac (str): l'indirizzo MAC del computer.
:param value (obj): il dato da inserire.
:param selector (str): la chiave del dato da aggiornare.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_value(self, mac, value, selector):
        &#34;&#34;&#34;
        Inserisce o aggiorna un dato generico nel database.

        :param mac (str): l&#39;indirizzo MAC del computer.
        :param value (obj): il dato da inserire.
        :param selector (str): la chiave del dato da aggiornare.
        &#34;&#34;&#34;
        self.computerColl.find_one_and_update({&#39;mac&#39;: mac},
                {&#39;$set&#39;: {selector: value}}, upsert=True)</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.upsert_details"><code class="name flex">
<span>def <span class="ident">upsert_details</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Analizza i dati passati e li inserisce o li aggiorna nel database.</p>
<p>:param data (dict): il dizionario con i vari elementi da inserire.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upsert_details(self, data):
        &#34;&#34;&#34;
        Analizza i dati passati e li inserisce o li aggiorna nel database.

        :param data (dict): il dizionario con i vari elementi da inserire.
        &#34;&#34;&#34;
        try:
                if data is None or &#39;mac&#39; not in data:
                        return
                # verifica i dati per ogni attributo, dato che
                # necessitano di essere trattati in modo differente tra loro
                for attr in data:
                        # il mac è sempre uguale; non va modificato
                        if attr == &#39;mac&#39;:
                                continue
                        elif attr == &#39;model&#39;:
                                # se è una lista, va verificato singolarmente ogni elemento
                                if type(data[attr]) == list:
                                        for e in data[attr]:
                                                self.update_conn(data[&#39;mac&#39;], e)
                                else:
                                        self.update_conn(data[&#39;mac&#39;], data[attr])
                        else:
                                # i dizionari necessitano di una chiave ulteriore
                                if type(data[attr]) == dict and data[attr] != {}:
                                        for key in list(data[attr].keys()):
                                                self.update_value(data[&#39;mac&#39;], data[attr][key], attr+&#39;.&#39;+key)
                                else:
                                        self.update_value(data[&#39;mac&#39;], data[attr], attr)
        except Exception as e:
                self.log_db_error(e)</code></pre>
</details>
</dd>
<dt id="src.server.dbHelper.DbHelper.upsert_notif"><code class="name flex">
<span>def <span class="ident">upsert_notif</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Aggiorna o crea la notifica in base al parametro data.</p>
<p>:param data (dict): i nuovi dati nella notifica
:return: il documento della notifica modificata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upsert_notif(self, data):
        &#34;&#34;&#34;
        Aggiorna o crea la notifica in base al parametro data.
        
        :param data (dict): i nuovi dati nella notifica 
        :return: il documento della notifica modificata.
        &#34;&#34;&#34;
        try:
                return self.notifColl.find_one_and_update(
                        {&#39;name&#39;: data[&#39;name&#39;]},
                        {&#39;$set&#39;: data}, upsert=True
                ) if &#39;name&#39; in data else None
        except Exception as e:
                self.log_db_error(e)
        return []</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.server" href="index.html">src.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.server.dbHelper.DbHelper" href="#src.server.dbHelper.DbHelper">DbHelper</a></code></h4>
<ul class="two-column">
<li><code><a title="src.server.dbHelper.DbHelper.IP" href="#src.server.dbHelper.DbHelper.IP">IP</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.PORT" href="#src.server.dbHelper.DbHelper.PORT">PORT</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.add_buffered_notif" href="#src.server.dbHelper.DbHelper.add_buffered_notif">add_buffered_notif</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.clean_buffer" href="#src.server.dbHelper.DbHelper.clean_buffer">clean_buffer</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.delete_buffer" href="#src.server.dbHelper.DbHelper.delete_buffer">delete_buffer</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.delete_notif" href="#src.server.dbHelper.DbHelper.delete_notif">delete_notif</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.get_buffer" href="#src.server.dbHelper.DbHelper.get_buffer">get_buffer</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.get_computer_data" href="#src.server.dbHelper.DbHelper.get_computer_data">get_computer_data</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.get_notif" href="#src.server.dbHelper.DbHelper.get_notif">get_notif</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.get_notif_data" href="#src.server.dbHelper.DbHelper.get_notif_data">get_notif_data</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.get_notif_id" href="#src.server.dbHelper.DbHelper.get_notif_id">get_notif_id</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.log_db_error" href="#src.server.dbHelper.DbHelper.log_db_error">log_db_error</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.login" href="#src.server.dbHelper.DbHelper.login">login</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.update_buffer" href="#src.server.dbHelper.DbHelper.update_buffer">update_buffer</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.update_conn" href="#src.server.dbHelper.DbHelper.update_conn">update_conn</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.update_value" href="#src.server.dbHelper.DbHelper.update_value">update_value</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.upsert_details" href="#src.server.dbHelper.DbHelper.upsert_details">upsert_details</a></code></li>
<li><code><a title="src.server.dbHelper.DbHelper.upsert_notif" href="#src.server.dbHelper.DbHelper.upsert_notif">upsert_notif</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>