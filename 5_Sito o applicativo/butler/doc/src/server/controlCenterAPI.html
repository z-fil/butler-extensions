<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.server.controlCenterAPI API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.server.controlCenterAPI</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from flask import request
import threading
from os import _exit

from common import log
from common.notificationBuilder import NotificationBuilder
from common.baseAPI import BaseAPI
from server.ipParser import IPParser

class ControlCenterAPI(BaseAPI):
        &#34;&#34;&#34;
        Questa classe permette il controllo del programma server tramite richieste REST.
        Estende da BaseAPI che definisce parte della logica di base.
        &#34;&#34;&#34;

        def __init__(self, ip, port, expireTime, sslConf, callbacks, dbHelper, imagesPath, previewPort, guiAddr, guiSections):
                &#34;&#34;&#34;
                Istanzia un oggetto ControlCenterAPI definendone ip e porta sul quale lavorare,
                la durata dei token generati, le funzioni di callback disponibili, l&#39;oggetto
                per eseguire query al database, il percorso nel quale trovare le
                immagini delle notifiche, la porta della preview live, l&#39;indirizzo
                dell&#39;interfaccia grafica e le sezioni di default della GUI.
                
                :param ip (str): l&#39;ip sul quale attivare l&#39;API.
                :param port (int): la porta specifica dell&#39;API.
                :param expireTime (float): i minuti di durata dei token.
                :param sslConf (list): il percorso del certificato e della chiave SSL.
                :param callbacks (dict): la lista di callback, identificate da chiavi.
                :param dbHelper (DbHelper): l&#39;oggetto già configurato per la comunicazione
                        con il database MongoDB.
                :param imagesPath (str): il percorso di default nel quale trovare le immagini
                        delle notifiche, se i dati non dovessero contenere il base64 dell&#39;immagine.
                :param previewAddr (int): la porta sulla quale cercare l&#39;anteprima live.
                :param guiAddr (str): l&#39;indirizzo e la porta dell&#39;interfaccia grafica
                        dalla quale accettare richieste anche se riconosciute come cross-domain.
                :param guiSections (list): la lista con i nomi delle sezioni del centro di controllo.
                &#34;&#34;&#34;
                super().__init__(ip, port, expireTime, sslConf, callbacks)
                self.sections = guiSections
                self.db = dbHelper
                self.guiAddr = guiAddr
                # la preview funziona solo in HTTP
                self.previewAddr = &#39;http://&#39;+ip+&#39;:&#39;+str(previewPort)
                self.previewPort = previewPort
                self.preview = NotificationBuilder(port=previewPort, imagesPath=imagesPath)
                self.timer = 0

        def start_api(self):
                &#34;&#34;&#34;
                Avvia l&#39;API con alcuni endpoints accessibili agli amministratori.
                &#34;&#34;&#34;
                super().start_api()

                @self.flask.route(&#39;/authenticate&#39;, methods=[&#39;POST&#39;])
                def authenticate():
                        &#34;&#34;&#34;
                        Permette l&#39;autenticazione per l&#39;uso del centro di controllo.
                        
                        :return: il token JWT generato.
                        &#34;&#34;&#34;
                        user = self.get_json(request, &#39;username&#39;, &#39;&#39;)
                        password = self.get_json(request, &#39;password&#39;, &#39;&#39;)
                        if self.callbacks[&#39;validate_credentials&#39;](user, password):
                                self.sub = user
                                returnData = self.init_token()
                                log.info(returnData[&#39;message&#39;])
                                return self.standard_response(returnData)
                        returnData = {&#39;message&#39;: &#39;Credenziali non valide&#39;}
                        log.warning(returnData[&#39;message&#39;])
                        return self.standard_response(returnData, self.UNAUTHORIZED)

                @self.flask.route(&#39;/notifData&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_notif_data():
                        &#34;&#34;&#34;
                        Permette di ricavare i dati di una notifica in base al suo nome.
                        
                        :return: il nome della notifica da cercare nel database.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, None)
                        returnData = {
                                &#39;notif&#39;: self.db.get_notif_data(name)
                        }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/notifList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_notif_list():
                        &#34;&#34;&#34;
                        Permette di ricavare la lista delle notifiche
                        
                        :return: la lista dei nomi delle notifiche nel database.
                        &#34;&#34;&#34;
                        returnData = {&#39;notifList&#39;: [notif[&#39;name&#39;] if &#39;name&#39; in notif else &#39;&#39;
                                for notif in self.db.get_notif(filter={&#39;_id&#39;: 0, &#39;name&#39;: 1})] }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/butlers&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
                @self.auth.token_required
                def get_butler_list():
                        &#34;&#34;&#34;
                        Controlla lo stato dei Butlers e ritorna i dati di quelli ancora connessi.
                        
                        :return: la lista con alcune informazioni sui Butlers attivi.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        returnData = {
                                &#39;butlers&#39;: self.callbacks[&#39;check_butlers&#39;](addr),
                                &#39;message&#39;: &#39;Lista di Butlers aggiornata.&#39;
                        }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/imagesList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_images_list():
                        &#34;&#34;&#34;
                        Genera la lista di immagini utilizzabili.
                        
                        :return: la lista delle immagini trovate nel percorso definito
                                nella configurazione del programma.
                        &#34;&#34;&#34;
                        returnData = {&#39;imagesList&#39;: self.callbacks[&#39;get_files&#39;](&#39;imagesPath&#39;) }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/scriptsList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_scripts_list():
                        &#34;&#34;&#34;
                        Genera la lista di scripts utilizzabili.
                        
                        :return: la lista degli scripts trovati nel percorso definito
                                nella configurazione del programma.
                        &#34;&#34;&#34;
                        returnData = {&#39;scriptsList&#39;: self.callbacks[&#39;get_files&#39;](&#39;scriptsPath&#39;) }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/themesList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_themes():
                        &#34;&#34;&#34;
                        Genera la lista di temi delle notifice disponibili.
                        
                        :return: la lista dei nomi dei temi (definiti da PySimpleGUI).
                        &#34;&#34;&#34;
                        returnData = {&#39;themesList&#39;: self.preview.get_themes() }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/canDisconnect&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def set_can_disconnect():
                        &#34;&#34;&#34;
                        Imposta il permesso di disconnessione per un determinato Butler.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        permission = self.get_json(request, &#39;permission&#39;, &#39;&#39;)
                        self.callbacks[&#39;can_disconnect&#39;](addr, permission)

                        returnData = {
                                &#39;addr&#39;: addr,
                                &#39;message&#39;: &#39;{} {} disconnettersi.&#39;.format(
                                        addr, &#39;può ora&#39; if permission else &#39;non può più&#39;)
                        }
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/disconnect&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def disconnect_host():
                        &#34;&#34;&#34;
                        Forza la disconnessione di un Butler.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        self.callbacks[&#39;force_disconnect&#39;](addr)

                        returnData = {
                                &#39;butlers&#39;: {&#39;addr&#39;: addr},
                                &#34;message&#34;: &#39;{} disconnesso.&#39;.format(addr)
                        }
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/saveNotif&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def save_notif():
                        &#34;&#34;&#34;
                        Salva una notifica in base ai dati passati.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        notifData = self.get_json(request, &#39;notif&#39;, [])
                        if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                                self.db.upsert_notif(notifData)
                                returnData = {
                                        &#39;message&#39;: &#39;Notifica &#34;{}&#34; salvata&#39;.format(notifData[&#39;name&#39;])
                                }
                                log.info(returnData[&#39;message&#39;])
                                return self.standard_response(returnData)
                        returnData = {&#39;message&#39;: &#39;La notifica non è stata salvata poichè sprovvista di nome.&#39;}
                        log.warning(returnData[&#39;message&#39;])
                        return self.standard_response({&#39;message&#39;: &#39;Dati mancanti&#39;}, self.UNAUTHORIZED)

                @self.flask.route(&#39;/sendNotif&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def send_notif():
                        &#34;&#34;&#34;
                        Permette di inviare una notifica ai Butlers.
                        La notifica è accettata solo se ha dei destinatari validi, un nome
                        e dei dati a questo associati. 
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, None)
                        deliveryData = self.get_json(request, &#39;buffer&#39;, [])
                        returnData = {&#39;message&#39;: &#39;Dati della notifica non validi o mancanti.&#39;}
                        status = self.UNAUTHORIZED

                        if &#39;recipients&#39; in deliveryData and len(deliveryData[&#39;recipients&#39;]) &gt; 0 and self.db.get_notif_data(name) != []:
                                if deliveryData[&#39;recipients&#39;] == &#39;*&#39;:
                                        # &#39;*&#39; non è accettato nel buffer, poichè creerebbe problemi
                                        # con la rimozione dei destinatari
                                        deliveryData[&#39;recipients&#39;] = [
                                                addr for addr in self.callbacks[&#39;check_butlers&#39;]()]
                                if deliveryData[&#39;start&#39;] != &#39;&#39;:
                                        self.db.add_buffered_notif(
                                                name, deliveryData[&#39;recipients&#39;], deliveryData[&#39;start&#39;])
                                        returnData[&#39;message&#39;] = &#39;Buffer della notifica &#34;{}&#34; salvato con inizio della consegna {}&#39;.format(
                                                name, deliveryData[&#39;start&#39;])
                                else:
                                        returnData[&#39;message&#39;] = &#39;Notifica inviata a: {}&#39;.format(
                                                [addr for addr in self.callbacks[&#39;send_notif&#39;](name, deliveryData[&#39;recipients&#39;])])
                                status = self.ACCEPTED
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData, status)

                @self.flask.route(&#39;/deleteNotif&#39;, methods=[&#39;DELETE&#39;])
                @self.auth.token_required
                def delete_notif():
                        &#34;&#34;&#34;
                        Permette di eliminare una notifica in base al nome.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, &#39;&#39;)
                        if name != &#39;&#39;:
                                self.db.delete_notif(name)
                                returnData = {&#39;message&#39;: &#39;Notifica &#34;{}&#34; eliminata&#39;.format(name)}
                                log.info(returnData[&#39;message&#39;])
                                return self.standard_response(returnData)
                        returnData = {&#39;message&#39;: &#39;Nome non specificato&#39;}
                        log.warning(returnData[&#39;message&#39;])
                        return self.standard_response(returnData, self.UNAUTHORIZED)


                @self.flask.route(&#39;/revoke&#39;, methods=[&#39;DELETE&#39;])
                @self.auth.token_required
                def revoke_notif():
                        &#34;&#34;&#34;
                        Permette di forzare la chiusura di una notifica su tutti i Butlers.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, &#39;&#39;)
                        self.callbacks[&#39;revoke&#39;](name)

                        returnData = { &#39;message&#39;: &#39;Notifica &#34;{}&#34; revocata da tutti i Butlers&#39;.format(name) }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/verifyList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def verify_recipients_list():
                        &#34;&#34;&#34;
                        Permette di verificare in anticipo la lista di destinatari,
                        usando l&#39;apposita classe.
                        
                        :return: la lista di indirizzi IP validi nella lista
                                (non ritorna gli host attivi che riceverebbero la notifica).
                        &#34;&#34;&#34;
                        recipients = self.get_json(request, &#39;recipients&#39;, [])
                        returnData = IPParser().sanitize_ips(recipients) if recipients != &#39;*&#39; else [&#39;*&#39;]
                        return self.standard_response(returnData)
                        
                @self.flask.route(&#39;/refreshPreview&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def refresh_preview():
                        &#34;&#34;&#34;
                        Gestisce e aggiorna l&#39;anteprima live in base ai dati ricevuti.
                        
                        :return: i secondi da attendere prima della prossima richiesta.
                                È in questo modo che la sezione della preview informa ufficialmente
                                l&#39;editor che deve mandare i dati aggiornati al server.
                        &#34;&#34;&#34;
                        notifData = self.get_json(request, &#39;notif&#39;, {&#39;name&#39;:&#39;&#39;})
                        if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                                try:
                                        threading.Thread(
                                                target=self.preview.show_window, args=[notifData]).start()
                                except Exception as e:
                                        self.preview.stop()
                                        log(&#39;Errore nell\&#39;anteprima live: {}&#39;.format(e.__str__()))
                                
                        returnData = {&#39;timer&#39;: self.timer}
                        return self.standard_response(returnData)
                        
                @self.flask.route(&#39;/setTimer&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def set_timer():
                        &#34;&#34;&#34;
                        Permette di impostare la cadenza di aggiornamento dei dati delle notifiche.
                        
                        :return: una risposta vuota di successo.
                        &#34;&#34;&#34;
                        self.timer = self.get_json(request, &#39;timer&#39;, &#39;&#39;)

                        return self.standard_response()
          
                @self.flask.route(&#39;/testNotif&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def test_notif():
                        notifData = self.get_json(request, &#39;notif&#39;, {&#39;name&#39;: &#39;&#39;})
                        if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                                self.callbacks[&#39;test_notif&#39;](notifData)
                        return self.standard_response({&#39;message&#39;: &#39;Notifica di test &#34;{}&#34; autoinviata&#39;.format(notifData[&#39;name&#39;])})

                @self.flask.route(&#39;/previewAddr&#39;, methods=[&#39;GET&#39;])
                @self.auth.token_required
                def get_addr():
                        &#34;&#34;&#34;
                        Permette di ricavare l&#39;indirizzo per raggiungere l&#39;anteprima della notifica.
                        
                        :return: l&#39;indirizzo sul quale raggiungere l&#39;anteprima.
                        &#34;&#34;&#34;
                        log.info(&#39;Preview della notifica sull\&#39;indirizzo {}&#39;.format(self.previewAddr))
                        returnData = {&#39;addr&#39;: self.previewAddr}
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/sections&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
                @self.auth.token_required
                def get_sections():
                        &#34;&#34;&#34;
                        Permette di ricavare le sezioni dell&#39;interfaccia da caricare.
                        
                        :return: la lista di nomi delle sezioni.
                        &#34;&#34;&#34;
                        log.info(&#39;Caricate le sezioni grafiche {}&#39;.format(self.sections))
                        return self.standard_response(self.sections)

                @self.flask.after_request
                def after_request(response):
                        &#34;&#34;&#34;
                        Viene richiamata prima della ricezione della richiesta.
                        Imposta alcuni parametri per permettere di accettare richieste sicure
                        da porte diverse da quella di questa API.
                        
                        :param response (response): la risposta da modificare.
                        
                        :return: la risposta modificata.
                        &#34;&#34;&#34;
                        response.headers[&#34;Access-Control-Allow-Origin&#34;] = &#39;{}&#39;.format(self.guiAddr)
                        #response.headers[&#34;Access-Control-Allow-Credentials&#34;] = &#34;true&#34;
                        response.headers[&#34;Access-Control-Allow-Methods&#34;] = &#39;POST, GET, PUT, DELETE&#39;
                        response.headers[&#34;Access-Control-Allow-Headers&#34;] = &#39;Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, token, sub&#39;
                        return response


                &#34;&#34;&#34;
                #####################################
                Funzioni aggiuntive butler-extensions
                #####################################
                &#34;&#34;&#34;

                @self.flask.route(&#39;/details&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
                @self.auth.token_required
                def get_details():
                        &#34;&#34;&#34;
                        Permette di ricavare i dettagli su un Butler.

                        :return: i dettagli ricevuti.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        details = self.callbacks[&#39;get_butler_details&#39;](addr)
                        status = self.ACCEPTED
                        # se i dettagli sono vuoti, il Butler non ha risposto
                        if details == {}:
                                status = self.UNAUTHORIZED
                                details = {&#39;message&#39;: &#39;Il Butler {} non ha risposto alla richiesta: potrebbe essere offline&#39;.format(addr)}
                        # se dei dettagli mancano i moduli, il database non ha ritornato dati
                        elif &#39;modules&#39; not in details:
                                status = self.UNAUTHORIZED
                                details = {&#39;message&#39;: &#39;Errore nella lettura del database: potrebbe essere offline&#39;}


                        return self.standard_response(details, code=status)

                @self.flask.route(&#39;/module&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def toggle_module():
                        &#34;&#34;&#34;
                        Permette di modificare lo stato dei moduli dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        return self.edit_butler(request)

                @self.flask.route(&#39;/phase&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def toggle_phase():
                        &#34;&#34;&#34;
                        Permette di modificare la fase del modulo di comportamento dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        return self.edit_butler(request)

                @self.flask.route(&#39;/connection&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def edit_connection():
                        &#34;&#34;&#34;
                        Permette di modificare la sicurezza delle connessioni dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        return self.edit_butler(request)

                @self.flask.route(&#39;/standardModel&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def apply_standard_model():
                        &#34;&#34;&#34;
                        Permette di modificare la sicurezza delle connessioni dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        editNum = self.callbacks[&#39;apply_standard_model&#39;](addr)
                        returnData = {&#39;message&#39;: &#39;{} connessioni applicate a {}&#39;.format(editNum, addr)}
                        return self.standard_response(returnData)

                &#34;&#34;&#34;
                ##########################################
                Fine funzioni aggiuntive butler-extensions
                ##########################################
                &#34;&#34;&#34;
                

                try:
                        log.info(&#39;API di controllo avviata su {}:{}&#39;.format(self.ip, self.port))
                        self.flask.run(host=self.ip, port=self.port, ssl_context=self.sslConf)
                except OSError as e:
                        log.critical(&#39;Non è stato possibile avviare il centro di controllo su &#34;{}&#34;: {}&#39;.format(self.ip, e.__str__()))
                        _exit(1)


        &#34;&#34;&#34;
        #####################################
        Funzioni aggiuntive butler-extensions
        #####################################
        &#34;&#34;&#34;

        def edit_butler(self, request):
                &#34;&#34;&#34;
                Permette di modificare un parametro di un Butler,
                usando l&#39;attributo &#34;data&#34; per ricavare le informazioni passate.

                :param request (flask.request): il contesto della richiesta ricevuta.

                :return: una risposta vuota di successo.
                &#34;&#34;&#34;
                addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                data = self.get_json(request, &#39;data&#39;, [])
                # request.path corrisponde sia all&#39;endpoint appena raggiunto che a quello del client
                self.callbacks[&#39;edit_butler&#39;](addr, data, request.path)
                return self.standard_response()
                
        &#34;&#34;&#34;
        ##########################################
        Fine funzioni aggiuntive butler-extensions
        ##########################################
        &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.server.controlCenterAPI.ControlCenterAPI"><code class="flex name class">
<span>class <span class="ident">ControlCenterAPI</span></span>
<span>(</span><span>ip, port, expireTime, sslConf, callbacks, dbHelper, imagesPath, previewPort, guiAddr, guiSections)</span>
</code></dt>
<dd>
<div class="desc"><p>Questa classe permette il controllo del programma server tramite richieste REST.
Estende da BaseAPI che definisce parte della logica di base.</p>
<p>Istanzia un oggetto ControlCenterAPI definendone ip e porta sul quale lavorare,
la durata dei token generati, le funzioni di callback disponibili, l'oggetto
per eseguire query al database, il percorso nel quale trovare le
immagini delle notifiche, la porta della preview live, l'indirizzo
dell'interfaccia grafica e le sezioni di default della GUI.</p>
<p>:param ip (str): l'ip sul quale attivare l'API.
:param port (int): la porta specifica dell'API.
:param expireTime (float): i minuti di durata dei token.
:param sslConf (list): il percorso del certificato e della chiave SSL.
:param callbacks (dict): la lista di callback, identificate da chiavi.
:param dbHelper (DbHelper): l'oggetto già configurato per la comunicazione
con il database MongoDB.
:param imagesPath (str): il percorso di default nel quale trovare le immagini
delle notifiche, se i dati non dovessero contenere il base64 dell'immagine.
:param previewAddr (int): la porta sulla quale cercare l'anteprima live.
:param guiAddr (str): l'indirizzo e la porta dell'interfaccia grafica
dalla quale accettare richieste anche se riconosciute come cross-domain.
:param guiSections (list): la lista con i nomi delle sezioni del centro di controllo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControlCenterAPI(BaseAPI):
        &#34;&#34;&#34;
        Questa classe permette il controllo del programma server tramite richieste REST.
        Estende da BaseAPI che definisce parte della logica di base.
        &#34;&#34;&#34;

        def __init__(self, ip, port, expireTime, sslConf, callbacks, dbHelper, imagesPath, previewPort, guiAddr, guiSections):
                &#34;&#34;&#34;
                Istanzia un oggetto ControlCenterAPI definendone ip e porta sul quale lavorare,
                la durata dei token generati, le funzioni di callback disponibili, l&#39;oggetto
                per eseguire query al database, il percorso nel quale trovare le
                immagini delle notifiche, la porta della preview live, l&#39;indirizzo
                dell&#39;interfaccia grafica e le sezioni di default della GUI.
                
                :param ip (str): l&#39;ip sul quale attivare l&#39;API.
                :param port (int): la porta specifica dell&#39;API.
                :param expireTime (float): i minuti di durata dei token.
                :param sslConf (list): il percorso del certificato e della chiave SSL.
                :param callbacks (dict): la lista di callback, identificate da chiavi.
                :param dbHelper (DbHelper): l&#39;oggetto già configurato per la comunicazione
                        con il database MongoDB.
                :param imagesPath (str): il percorso di default nel quale trovare le immagini
                        delle notifiche, se i dati non dovessero contenere il base64 dell&#39;immagine.
                :param previewAddr (int): la porta sulla quale cercare l&#39;anteprima live.
                :param guiAddr (str): l&#39;indirizzo e la porta dell&#39;interfaccia grafica
                        dalla quale accettare richieste anche se riconosciute come cross-domain.
                :param guiSections (list): la lista con i nomi delle sezioni del centro di controllo.
                &#34;&#34;&#34;
                super().__init__(ip, port, expireTime, sslConf, callbacks)
                self.sections = guiSections
                self.db = dbHelper
                self.guiAddr = guiAddr
                # la preview funziona solo in HTTP
                self.previewAddr = &#39;http://&#39;+ip+&#39;:&#39;+str(previewPort)
                self.previewPort = previewPort
                self.preview = NotificationBuilder(port=previewPort, imagesPath=imagesPath)
                self.timer = 0

        def start_api(self):
                &#34;&#34;&#34;
                Avvia l&#39;API con alcuni endpoints accessibili agli amministratori.
                &#34;&#34;&#34;
                super().start_api()

                @self.flask.route(&#39;/authenticate&#39;, methods=[&#39;POST&#39;])
                def authenticate():
                        &#34;&#34;&#34;
                        Permette l&#39;autenticazione per l&#39;uso del centro di controllo.
                        
                        :return: il token JWT generato.
                        &#34;&#34;&#34;
                        user = self.get_json(request, &#39;username&#39;, &#39;&#39;)
                        password = self.get_json(request, &#39;password&#39;, &#39;&#39;)
                        if self.callbacks[&#39;validate_credentials&#39;](user, password):
                                self.sub = user
                                returnData = self.init_token()
                                log.info(returnData[&#39;message&#39;])
                                return self.standard_response(returnData)
                        returnData = {&#39;message&#39;: &#39;Credenziali non valide&#39;}
                        log.warning(returnData[&#39;message&#39;])
                        return self.standard_response(returnData, self.UNAUTHORIZED)

                @self.flask.route(&#39;/notifData&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_notif_data():
                        &#34;&#34;&#34;
                        Permette di ricavare i dati di una notifica in base al suo nome.
                        
                        :return: il nome della notifica da cercare nel database.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, None)
                        returnData = {
                                &#39;notif&#39;: self.db.get_notif_data(name)
                        }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/notifList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_notif_list():
                        &#34;&#34;&#34;
                        Permette di ricavare la lista delle notifiche
                        
                        :return: la lista dei nomi delle notifiche nel database.
                        &#34;&#34;&#34;
                        returnData = {&#39;notifList&#39;: [notif[&#39;name&#39;] if &#39;name&#39; in notif else &#39;&#39;
                                for notif in self.db.get_notif(filter={&#39;_id&#39;: 0, &#39;name&#39;: 1})] }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/butlers&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
                @self.auth.token_required
                def get_butler_list():
                        &#34;&#34;&#34;
                        Controlla lo stato dei Butlers e ritorna i dati di quelli ancora connessi.
                        
                        :return: la lista con alcune informazioni sui Butlers attivi.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        returnData = {
                                &#39;butlers&#39;: self.callbacks[&#39;check_butlers&#39;](addr),
                                &#39;message&#39;: &#39;Lista di Butlers aggiornata.&#39;
                        }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/imagesList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_images_list():
                        &#34;&#34;&#34;
                        Genera la lista di immagini utilizzabili.
                        
                        :return: la lista delle immagini trovate nel percorso definito
                                nella configurazione del programma.
                        &#34;&#34;&#34;
                        returnData = {&#39;imagesList&#39;: self.callbacks[&#39;get_files&#39;](&#39;imagesPath&#39;) }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/scriptsList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_scripts_list():
                        &#34;&#34;&#34;
                        Genera la lista di scripts utilizzabili.
                        
                        :return: la lista degli scripts trovati nel percorso definito
                                nella configurazione del programma.
                        &#34;&#34;&#34;
                        returnData = {&#39;scriptsList&#39;: self.callbacks[&#39;get_files&#39;](&#39;scriptsPath&#39;) }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/themesList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def get_themes():
                        &#34;&#34;&#34;
                        Genera la lista di temi delle notifice disponibili.
                        
                        :return: la lista dei nomi dei temi (definiti da PySimpleGUI).
                        &#34;&#34;&#34;
                        returnData = {&#39;themesList&#39;: self.preview.get_themes() }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/canDisconnect&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def set_can_disconnect():
                        &#34;&#34;&#34;
                        Imposta il permesso di disconnessione per un determinato Butler.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        permission = self.get_json(request, &#39;permission&#39;, &#39;&#39;)
                        self.callbacks[&#39;can_disconnect&#39;](addr, permission)

                        returnData = {
                                &#39;addr&#39;: addr,
                                &#39;message&#39;: &#39;{} {} disconnettersi.&#39;.format(
                                        addr, &#39;può ora&#39; if permission else &#39;non può più&#39;)
                        }
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/disconnect&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def disconnect_host():
                        &#34;&#34;&#34;
                        Forza la disconnessione di un Butler.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        self.callbacks[&#39;force_disconnect&#39;](addr)

                        returnData = {
                                &#39;butlers&#39;: {&#39;addr&#39;: addr},
                                &#34;message&#34;: &#39;{} disconnesso.&#39;.format(addr)
                        }
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/saveNotif&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def save_notif():
                        &#34;&#34;&#34;
                        Salva una notifica in base ai dati passati.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        notifData = self.get_json(request, &#39;notif&#39;, [])
                        if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                                self.db.upsert_notif(notifData)
                                returnData = {
                                        &#39;message&#39;: &#39;Notifica &#34;{}&#34; salvata&#39;.format(notifData[&#39;name&#39;])
                                }
                                log.info(returnData[&#39;message&#39;])
                                return self.standard_response(returnData)
                        returnData = {&#39;message&#39;: &#39;La notifica non è stata salvata poichè sprovvista di nome.&#39;}
                        log.warning(returnData[&#39;message&#39;])
                        return self.standard_response({&#39;message&#39;: &#39;Dati mancanti&#39;}, self.UNAUTHORIZED)

                @self.flask.route(&#39;/sendNotif&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def send_notif():
                        &#34;&#34;&#34;
                        Permette di inviare una notifica ai Butlers.
                        La notifica è accettata solo se ha dei destinatari validi, un nome
                        e dei dati a questo associati. 
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, None)
                        deliveryData = self.get_json(request, &#39;buffer&#39;, [])
                        returnData = {&#39;message&#39;: &#39;Dati della notifica non validi o mancanti.&#39;}
                        status = self.UNAUTHORIZED

                        if &#39;recipients&#39; in deliveryData and len(deliveryData[&#39;recipients&#39;]) &gt; 0 and self.db.get_notif_data(name) != []:
                                if deliveryData[&#39;recipients&#39;] == &#39;*&#39;:
                                        # &#39;*&#39; non è accettato nel buffer, poichè creerebbe problemi
                                        # con la rimozione dei destinatari
                                        deliveryData[&#39;recipients&#39;] = [
                                                addr for addr in self.callbacks[&#39;check_butlers&#39;]()]
                                if deliveryData[&#39;start&#39;] != &#39;&#39;:
                                        self.db.add_buffered_notif(
                                                name, deliveryData[&#39;recipients&#39;], deliveryData[&#39;start&#39;])
                                        returnData[&#39;message&#39;] = &#39;Buffer della notifica &#34;{}&#34; salvato con inizio della consegna {}&#39;.format(
                                                name, deliveryData[&#39;start&#39;])
                                else:
                                        returnData[&#39;message&#39;] = &#39;Notifica inviata a: {}&#39;.format(
                                                [addr for addr in self.callbacks[&#39;send_notif&#39;](name, deliveryData[&#39;recipients&#39;])])
                                status = self.ACCEPTED
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData, status)

                @self.flask.route(&#39;/deleteNotif&#39;, methods=[&#39;DELETE&#39;])
                @self.auth.token_required
                def delete_notif():
                        &#34;&#34;&#34;
                        Permette di eliminare una notifica in base al nome.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, &#39;&#39;)
                        if name != &#39;&#39;:
                                self.db.delete_notif(name)
                                returnData = {&#39;message&#39;: &#39;Notifica &#34;{}&#34; eliminata&#39;.format(name)}
                                log.info(returnData[&#39;message&#39;])
                                return self.standard_response(returnData)
                        returnData = {&#39;message&#39;: &#39;Nome non specificato&#39;}
                        log.warning(returnData[&#39;message&#39;])
                        return self.standard_response(returnData, self.UNAUTHORIZED)


                @self.flask.route(&#39;/revoke&#39;, methods=[&#39;DELETE&#39;])
                @self.auth.token_required
                def revoke_notif():
                        &#34;&#34;&#34;
                        Permette di forzare la chiusura di una notifica su tutti i Butlers.
                        
                        :return: il risultato dell&#39;operazione.
                        &#34;&#34;&#34;
                        name = self.get_json(request, &#39;name&#39;, &#39;&#39;)
                        self.callbacks[&#39;revoke&#39;](name)

                        returnData = { &#39;message&#39;: &#39;Notifica &#34;{}&#34; revocata da tutti i Butlers&#39;.format(name) }
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/verifyList&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def verify_recipients_list():
                        &#34;&#34;&#34;
                        Permette di verificare in anticipo la lista di destinatari,
                        usando l&#39;apposita classe.
                        
                        :return: la lista di indirizzi IP validi nella lista
                                (non ritorna gli host attivi che riceverebbero la notifica).
                        &#34;&#34;&#34;
                        recipients = self.get_json(request, &#39;recipients&#39;, [])
                        returnData = IPParser().sanitize_ips(recipients) if recipients != &#39;*&#39; else [&#39;*&#39;]
                        return self.standard_response(returnData)
                        
                @self.flask.route(&#39;/refreshPreview&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def refresh_preview():
                        &#34;&#34;&#34;
                        Gestisce e aggiorna l&#39;anteprima live in base ai dati ricevuti.
                        
                        :return: i secondi da attendere prima della prossima richiesta.
                                È in questo modo che la sezione della preview informa ufficialmente
                                l&#39;editor che deve mandare i dati aggiornati al server.
                        &#34;&#34;&#34;
                        notifData = self.get_json(request, &#39;notif&#39;, {&#39;name&#39;:&#39;&#39;})
                        if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                                try:
                                        threading.Thread(
                                                target=self.preview.show_window, args=[notifData]).start()
                                except Exception as e:
                                        self.preview.stop()
                                        log(&#39;Errore nell\&#39;anteprima live: {}&#39;.format(e.__str__()))
                                
                        returnData = {&#39;timer&#39;: self.timer}
                        return self.standard_response(returnData)
                        
                @self.flask.route(&#39;/setTimer&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def set_timer():
                        &#34;&#34;&#34;
                        Permette di impostare la cadenza di aggiornamento dei dati delle notifiche.
                        
                        :return: una risposta vuota di successo.
                        &#34;&#34;&#34;
                        self.timer = self.get_json(request, &#39;timer&#39;, &#39;&#39;)

                        return self.standard_response()
          
                @self.flask.route(&#39;/testNotif&#39;, methods=[&#39;POST&#39;])
                @self.auth.token_required
                def test_notif():
                        notifData = self.get_json(request, &#39;notif&#39;, {&#39;name&#39;: &#39;&#39;})
                        if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                                self.callbacks[&#39;test_notif&#39;](notifData)
                        return self.standard_response({&#39;message&#39;: &#39;Notifica di test &#34;{}&#34; autoinviata&#39;.format(notifData[&#39;name&#39;])})

                @self.flask.route(&#39;/previewAddr&#39;, methods=[&#39;GET&#39;])
                @self.auth.token_required
                def get_addr():
                        &#34;&#34;&#34;
                        Permette di ricavare l&#39;indirizzo per raggiungere l&#39;anteprima della notifica.
                        
                        :return: l&#39;indirizzo sul quale raggiungere l&#39;anteprima.
                        &#34;&#34;&#34;
                        log.info(&#39;Preview della notifica sull\&#39;indirizzo {}&#39;.format(self.previewAddr))
                        returnData = {&#39;addr&#39;: self.previewAddr}
                        return self.standard_response(returnData)

                @self.flask.route(&#39;/sections&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
                @self.auth.token_required
                def get_sections():
                        &#34;&#34;&#34;
                        Permette di ricavare le sezioni dell&#39;interfaccia da caricare.
                        
                        :return: la lista di nomi delle sezioni.
                        &#34;&#34;&#34;
                        log.info(&#39;Caricate le sezioni grafiche {}&#39;.format(self.sections))
                        return self.standard_response(self.sections)

                @self.flask.after_request
                def after_request(response):
                        &#34;&#34;&#34;
                        Viene richiamata prima della ricezione della richiesta.
                        Imposta alcuni parametri per permettere di accettare richieste sicure
                        da porte diverse da quella di questa API.
                        
                        :param response (response): la risposta da modificare.
                        
                        :return: la risposta modificata.
                        &#34;&#34;&#34;
                        response.headers[&#34;Access-Control-Allow-Origin&#34;] = &#39;{}&#39;.format(self.guiAddr)
                        #response.headers[&#34;Access-Control-Allow-Credentials&#34;] = &#34;true&#34;
                        response.headers[&#34;Access-Control-Allow-Methods&#34;] = &#39;POST, GET, PUT, DELETE&#39;
                        response.headers[&#34;Access-Control-Allow-Headers&#34;] = &#39;Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, token, sub&#39;
                        return response


                &#34;&#34;&#34;
                #####################################
                Funzioni aggiuntive butler-extensions
                #####################################
                &#34;&#34;&#34;

                @self.flask.route(&#39;/details&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
                @self.auth.token_required
                def get_details():
                        &#34;&#34;&#34;
                        Permette di ricavare i dettagli su un Butler.

                        :return: i dettagli ricevuti.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        details = self.callbacks[&#39;get_butler_details&#39;](addr)
                        status = self.ACCEPTED
                        # se i dettagli sono vuoti, il Butler non ha risposto
                        if details == {}:
                                status = self.UNAUTHORIZED
                                details = {&#39;message&#39;: &#39;Il Butler {} non ha risposto alla richiesta: potrebbe essere offline&#39;.format(addr)}
                        # se dei dettagli mancano i moduli, il database non ha ritornato dati
                        elif &#39;modules&#39; not in details:
                                status = self.UNAUTHORIZED
                                details = {&#39;message&#39;: &#39;Errore nella lettura del database: potrebbe essere offline&#39;}


                        return self.standard_response(details, code=status)

                @self.flask.route(&#39;/module&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def toggle_module():
                        &#34;&#34;&#34;
                        Permette di modificare lo stato dei moduli dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        return self.edit_butler(request)

                @self.flask.route(&#39;/phase&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def toggle_phase():
                        &#34;&#34;&#34;
                        Permette di modificare la fase del modulo di comportamento dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        return self.edit_butler(request)

                @self.flask.route(&#39;/connection&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def edit_connection():
                        &#34;&#34;&#34;
                        Permette di modificare la sicurezza delle connessioni dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        return self.edit_butler(request)

                @self.flask.route(&#39;/standardModel&#39;, methods=[&#39;PUT&#39;])
                @self.auth.token_required
                def apply_standard_model():
                        &#34;&#34;&#34;
                        Permette di modificare la sicurezza delle connessioni dei Butlers.

                        :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                        &#34;&#34;&#34;
                        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                        editNum = self.callbacks[&#39;apply_standard_model&#39;](addr)
                        returnData = {&#39;message&#39;: &#39;{} connessioni applicate a {}&#39;.format(editNum, addr)}
                        return self.standard_response(returnData)

                &#34;&#34;&#34;
                ##########################################
                Fine funzioni aggiuntive butler-extensions
                ##########################################
                &#34;&#34;&#34;
                

                try:
                        log.info(&#39;API di controllo avviata su {}:{}&#39;.format(self.ip, self.port))
                        self.flask.run(host=self.ip, port=self.port, ssl_context=self.sslConf)
                except OSError as e:
                        log.critical(&#39;Non è stato possibile avviare il centro di controllo su &#34;{}&#34;: {}&#39;.format(self.ip, e.__str__()))
                        _exit(1)


        &#34;&#34;&#34;
        #####################################
        Funzioni aggiuntive butler-extensions
        #####################################
        &#34;&#34;&#34;

        def edit_butler(self, request):
                &#34;&#34;&#34;
                Permette di modificare un parametro di un Butler,
                usando l&#39;attributo &#34;data&#34; per ricavare le informazioni passate.

                :param request (flask.request): il contesto della richiesta ricevuta.

                :return: una risposta vuota di successo.
                &#34;&#34;&#34;
                addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                data = self.get_json(request, &#39;data&#39;, [])
                # request.path corrisponde sia all&#39;endpoint appena raggiunto che a quello del client
                self.callbacks[&#39;edit_butler&#39;](addr, data, request.path)
                return self.standard_response()
                
        &#34;&#34;&#34;
        ##########################################
        Fine funzioni aggiuntive butler-extensions
        ##########################################
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>common.baseAPI.BaseAPI</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.server.controlCenterAPI.ControlCenterAPI.edit_butler"><code class="name flex">
<span>def <span class="ident">edit_butler</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<div class="desc"><p>Permette di modificare un parametro di un Butler,
usando l'attributo "data" per ricavare le informazioni passate.</p>
<p>:param request (flask.request): il contesto della richiesta ricevuta.</p>
<p>:return: una risposta vuota di successo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_butler(self, request):
        &#34;&#34;&#34;
        Permette di modificare un parametro di un Butler,
        usando l&#39;attributo &#34;data&#34; per ricavare le informazioni passate.

        :param request (flask.request): il contesto della richiesta ricevuta.

        :return: una risposta vuota di successo.
        &#34;&#34;&#34;
        addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
        data = self.get_json(request, &#39;data&#39;, [])
        # request.path corrisponde sia all&#39;endpoint appena raggiunto che a quello del client
        self.callbacks[&#39;edit_butler&#39;](addr, data, request.path)
        return self.standard_response()</code></pre>
</details>
</dd>
<dt id="src.server.controlCenterAPI.ControlCenterAPI.start_api"><code class="name flex">
<span>def <span class="ident">start_api</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Avvia l'API con alcuni endpoints accessibili agli amministratori.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_api(self):
        &#34;&#34;&#34;
        Avvia l&#39;API con alcuni endpoints accessibili agli amministratori.
        &#34;&#34;&#34;
        super().start_api()

        @self.flask.route(&#39;/authenticate&#39;, methods=[&#39;POST&#39;])
        def authenticate():
                &#34;&#34;&#34;
                Permette l&#39;autenticazione per l&#39;uso del centro di controllo.
                
                :return: il token JWT generato.
                &#34;&#34;&#34;
                user = self.get_json(request, &#39;username&#39;, &#39;&#39;)
                password = self.get_json(request, &#39;password&#39;, &#39;&#39;)
                if self.callbacks[&#39;validate_credentials&#39;](user, password):
                        self.sub = user
                        returnData = self.init_token()
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData)
                returnData = {&#39;message&#39;: &#39;Credenziali non valide&#39;}
                log.warning(returnData[&#39;message&#39;])
                return self.standard_response(returnData, self.UNAUTHORIZED)

        @self.flask.route(&#39;/notifData&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def get_notif_data():
                &#34;&#34;&#34;
                Permette di ricavare i dati di una notifica in base al suo nome.
                
                :return: il nome della notifica da cercare nel database.
                &#34;&#34;&#34;
                name = self.get_json(request, &#39;name&#39;, None)
                returnData = {
                        &#39;notif&#39;: self.db.get_notif_data(name)
                }
                return self.standard_response(returnData)

        @self.flask.route(&#39;/notifList&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def get_notif_list():
                &#34;&#34;&#34;
                Permette di ricavare la lista delle notifiche
                
                :return: la lista dei nomi delle notifiche nel database.
                &#34;&#34;&#34;
                returnData = {&#39;notifList&#39;: [notif[&#39;name&#39;] if &#39;name&#39; in notif else &#39;&#39;
                        for notif in self.db.get_notif(filter={&#39;_id&#39;: 0, &#39;name&#39;: 1})] }
                return self.standard_response(returnData)

        @self.flask.route(&#39;/butlers&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
        @self.auth.token_required
        def get_butler_list():
                &#34;&#34;&#34;
                Controlla lo stato dei Butlers e ritorna i dati di quelli ancora connessi.
                
                :return: la lista con alcune informazioni sui Butlers attivi.
                &#34;&#34;&#34;
                addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                returnData = {
                        &#39;butlers&#39;: self.callbacks[&#39;check_butlers&#39;](addr),
                        &#39;message&#39;: &#39;Lista di Butlers aggiornata.&#39;
                }
                return self.standard_response(returnData)

        @self.flask.route(&#39;/imagesList&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def get_images_list():
                &#34;&#34;&#34;
                Genera la lista di immagini utilizzabili.
                
                :return: la lista delle immagini trovate nel percorso definito
                        nella configurazione del programma.
                &#34;&#34;&#34;
                returnData = {&#39;imagesList&#39;: self.callbacks[&#39;get_files&#39;](&#39;imagesPath&#39;) }
                return self.standard_response(returnData)

        @self.flask.route(&#39;/scriptsList&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def get_scripts_list():
                &#34;&#34;&#34;
                Genera la lista di scripts utilizzabili.
                
                :return: la lista degli scripts trovati nel percorso definito
                        nella configurazione del programma.
                &#34;&#34;&#34;
                returnData = {&#39;scriptsList&#39;: self.callbacks[&#39;get_files&#39;](&#39;scriptsPath&#39;) }
                return self.standard_response(returnData)

        @self.flask.route(&#39;/themesList&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def get_themes():
                &#34;&#34;&#34;
                Genera la lista di temi delle notifice disponibili.
                
                :return: la lista dei nomi dei temi (definiti da PySimpleGUI).
                &#34;&#34;&#34;
                returnData = {&#39;themesList&#39;: self.preview.get_themes() }
                return self.standard_response(returnData)

        @self.flask.route(&#39;/canDisconnect&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def set_can_disconnect():
                &#34;&#34;&#34;
                Imposta il permesso di disconnessione per un determinato Butler.
                
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                permission = self.get_json(request, &#39;permission&#39;, &#39;&#39;)
                self.callbacks[&#39;can_disconnect&#39;](addr, permission)

                returnData = {
                        &#39;addr&#39;: addr,
                        &#39;message&#39;: &#39;{} {} disconnettersi.&#39;.format(
                                addr, &#39;può ora&#39; if permission else &#39;non può più&#39;)
                }
                log.info(returnData[&#39;message&#39;])
                return self.standard_response(returnData)

        @self.flask.route(&#39;/disconnect&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def disconnect_host():
                &#34;&#34;&#34;
                Forza la disconnessione di un Butler.
                
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                self.callbacks[&#39;force_disconnect&#39;](addr)

                returnData = {
                        &#39;butlers&#39;: {&#39;addr&#39;: addr},
                        &#34;message&#34;: &#39;{} disconnesso.&#39;.format(addr)
                }
                log.info(returnData[&#39;message&#39;])
                return self.standard_response(returnData)

        @self.flask.route(&#39;/saveNotif&#39;, methods=[&#39;PUT&#39;])
        @self.auth.token_required
        def save_notif():
                &#34;&#34;&#34;
                Salva una notifica in base ai dati passati.
                
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                notifData = self.get_json(request, &#39;notif&#39;, [])
                if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                        self.db.upsert_notif(notifData)
                        returnData = {
                                &#39;message&#39;: &#39;Notifica &#34;{}&#34; salvata&#39;.format(notifData[&#39;name&#39;])
                        }
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData)
                returnData = {&#39;message&#39;: &#39;La notifica non è stata salvata poichè sprovvista di nome.&#39;}
                log.warning(returnData[&#39;message&#39;])
                return self.standard_response({&#39;message&#39;: &#39;Dati mancanti&#39;}, self.UNAUTHORIZED)

        @self.flask.route(&#39;/sendNotif&#39;, methods=[&#39;PUT&#39;])
        @self.auth.token_required
        def send_notif():
                &#34;&#34;&#34;
                Permette di inviare una notifica ai Butlers.
                La notifica è accettata solo se ha dei destinatari validi, un nome
                e dei dati a questo associati. 
                
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                name = self.get_json(request, &#39;name&#39;, None)
                deliveryData = self.get_json(request, &#39;buffer&#39;, [])
                returnData = {&#39;message&#39;: &#39;Dati della notifica non validi o mancanti.&#39;}
                status = self.UNAUTHORIZED

                if &#39;recipients&#39; in deliveryData and len(deliveryData[&#39;recipients&#39;]) &gt; 0 and self.db.get_notif_data(name) != []:
                        if deliveryData[&#39;recipients&#39;] == &#39;*&#39;:
                                # &#39;*&#39; non è accettato nel buffer, poichè creerebbe problemi
                                # con la rimozione dei destinatari
                                deliveryData[&#39;recipients&#39;] = [
                                        addr for addr in self.callbacks[&#39;check_butlers&#39;]()]
                        if deliveryData[&#39;start&#39;] != &#39;&#39;:
                                self.db.add_buffered_notif(
                                        name, deliveryData[&#39;recipients&#39;], deliveryData[&#39;start&#39;])
                                returnData[&#39;message&#39;] = &#39;Buffer della notifica &#34;{}&#34; salvato con inizio della consegna {}&#39;.format(
                                        name, deliveryData[&#39;start&#39;])
                        else:
                                returnData[&#39;message&#39;] = &#39;Notifica inviata a: {}&#39;.format(
                                        [addr for addr in self.callbacks[&#39;send_notif&#39;](name, deliveryData[&#39;recipients&#39;])])
                        status = self.ACCEPTED
                log.info(returnData[&#39;message&#39;])
                return self.standard_response(returnData, status)

        @self.flask.route(&#39;/deleteNotif&#39;, methods=[&#39;DELETE&#39;])
        @self.auth.token_required
        def delete_notif():
                &#34;&#34;&#34;
                Permette di eliminare una notifica in base al nome.
                
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                name = self.get_json(request, &#39;name&#39;, &#39;&#39;)
                if name != &#39;&#39;:
                        self.db.delete_notif(name)
                        returnData = {&#39;message&#39;: &#39;Notifica &#34;{}&#34; eliminata&#39;.format(name)}
                        log.info(returnData[&#39;message&#39;])
                        return self.standard_response(returnData)
                returnData = {&#39;message&#39;: &#39;Nome non specificato&#39;}
                log.warning(returnData[&#39;message&#39;])
                return self.standard_response(returnData, self.UNAUTHORIZED)


        @self.flask.route(&#39;/revoke&#39;, methods=[&#39;DELETE&#39;])
        @self.auth.token_required
        def revoke_notif():
                &#34;&#34;&#34;
                Permette di forzare la chiusura di una notifica su tutti i Butlers.
                
                :return: il risultato dell&#39;operazione.
                &#34;&#34;&#34;
                name = self.get_json(request, &#39;name&#39;, &#39;&#39;)
                self.callbacks[&#39;revoke&#39;](name)

                returnData = { &#39;message&#39;: &#39;Notifica &#34;{}&#34; revocata da tutti i Butlers&#39;.format(name) }
                return self.standard_response(returnData)

        @self.flask.route(&#39;/verifyList&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def verify_recipients_list():
                &#34;&#34;&#34;
                Permette di verificare in anticipo la lista di destinatari,
                usando l&#39;apposita classe.
                
                :return: la lista di indirizzi IP validi nella lista
                        (non ritorna gli host attivi che riceverebbero la notifica).
                &#34;&#34;&#34;
                recipients = self.get_json(request, &#39;recipients&#39;, [])
                returnData = IPParser().sanitize_ips(recipients) if recipients != &#39;*&#39; else [&#39;*&#39;]
                return self.standard_response(returnData)
                
        @self.flask.route(&#39;/refreshPreview&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def refresh_preview():
                &#34;&#34;&#34;
                Gestisce e aggiorna l&#39;anteprima live in base ai dati ricevuti.
                
                :return: i secondi da attendere prima della prossima richiesta.
                        È in questo modo che la sezione della preview informa ufficialmente
                        l&#39;editor che deve mandare i dati aggiornati al server.
                &#34;&#34;&#34;
                notifData = self.get_json(request, &#39;notif&#39;, {&#39;name&#39;:&#39;&#39;})
                if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                        try:
                                threading.Thread(
                                        target=self.preview.show_window, args=[notifData]).start()
                        except Exception as e:
                                self.preview.stop()
                                log(&#39;Errore nell\&#39;anteprima live: {}&#39;.format(e.__str__()))
                        
                returnData = {&#39;timer&#39;: self.timer}
                return self.standard_response(returnData)
                
        @self.flask.route(&#39;/setTimer&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def set_timer():
                &#34;&#34;&#34;
                Permette di impostare la cadenza di aggiornamento dei dati delle notifiche.
                
                :return: una risposta vuota di successo.
                &#34;&#34;&#34;
                self.timer = self.get_json(request, &#39;timer&#39;, &#39;&#39;)

                return self.standard_response()
  
        @self.flask.route(&#39;/testNotif&#39;, methods=[&#39;POST&#39;])
        @self.auth.token_required
        def test_notif():
                notifData = self.get_json(request, &#39;notif&#39;, {&#39;name&#39;: &#39;&#39;})
                if &#39;name&#39; in notifData and notifData[&#39;name&#39;] != &#39;&#39;:
                        self.callbacks[&#39;test_notif&#39;](notifData)
                return self.standard_response({&#39;message&#39;: &#39;Notifica di test &#34;{}&#34; autoinviata&#39;.format(notifData[&#39;name&#39;])})

        @self.flask.route(&#39;/previewAddr&#39;, methods=[&#39;GET&#39;])
        @self.auth.token_required
        def get_addr():
                &#34;&#34;&#34;
                Permette di ricavare l&#39;indirizzo per raggiungere l&#39;anteprima della notifica.
                
                :return: l&#39;indirizzo sul quale raggiungere l&#39;anteprima.
                &#34;&#34;&#34;
                log.info(&#39;Preview della notifica sull\&#39;indirizzo {}&#39;.format(self.previewAddr))
                returnData = {&#39;addr&#39;: self.previewAddr}
                return self.standard_response(returnData)

        @self.flask.route(&#39;/sections&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
        @self.auth.token_required
        def get_sections():
                &#34;&#34;&#34;
                Permette di ricavare le sezioni dell&#39;interfaccia da caricare.
                
                :return: la lista di nomi delle sezioni.
                &#34;&#34;&#34;
                log.info(&#39;Caricate le sezioni grafiche {}&#39;.format(self.sections))
                return self.standard_response(self.sections)

        @self.flask.after_request
        def after_request(response):
                &#34;&#34;&#34;
                Viene richiamata prima della ricezione della richiesta.
                Imposta alcuni parametri per permettere di accettare richieste sicure
                da porte diverse da quella di questa API.
                
                :param response (response): la risposta da modificare.
                
                :return: la risposta modificata.
                &#34;&#34;&#34;
                response.headers[&#34;Access-Control-Allow-Origin&#34;] = &#39;{}&#39;.format(self.guiAddr)
                #response.headers[&#34;Access-Control-Allow-Credentials&#34;] = &#34;true&#34;
                response.headers[&#34;Access-Control-Allow-Methods&#34;] = &#39;POST, GET, PUT, DELETE&#39;
                response.headers[&#34;Access-Control-Allow-Headers&#34;] = &#39;Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, token, sub&#39;
                return response


        &#34;&#34;&#34;
        #####################################
        Funzioni aggiuntive butler-extensions
        #####################################
        &#34;&#34;&#34;

        @self.flask.route(&#39;/details&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
        @self.auth.token_required
        def get_details():
                &#34;&#34;&#34;
                Permette di ricavare i dettagli su un Butler.

                :return: i dettagli ricevuti.
                &#34;&#34;&#34;
                addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                details = self.callbacks[&#39;get_butler_details&#39;](addr)
                status = self.ACCEPTED
                # se i dettagli sono vuoti, il Butler non ha risposto
                if details == {}:
                        status = self.UNAUTHORIZED
                        details = {&#39;message&#39;: &#39;Il Butler {} non ha risposto alla richiesta: potrebbe essere offline&#39;.format(addr)}
                # se dei dettagli mancano i moduli, il database non ha ritornato dati
                elif &#39;modules&#39; not in details:
                        status = self.UNAUTHORIZED
                        details = {&#39;message&#39;: &#39;Errore nella lettura del database: potrebbe essere offline&#39;}


                return self.standard_response(details, code=status)

        @self.flask.route(&#39;/module&#39;, methods=[&#39;PUT&#39;])
        @self.auth.token_required
        def toggle_module():
                &#34;&#34;&#34;
                Permette di modificare lo stato dei moduli dei Butlers.

                :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                &#34;&#34;&#34;
                return self.edit_butler(request)

        @self.flask.route(&#39;/phase&#39;, methods=[&#39;PUT&#39;])
        @self.auth.token_required
        def toggle_phase():
                &#34;&#34;&#34;
                Permette di modificare la fase del modulo di comportamento dei Butlers.

                :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                &#34;&#34;&#34;
                return self.edit_butler(request)

        @self.flask.route(&#39;/connection&#39;, methods=[&#39;PUT&#39;])
        @self.auth.token_required
        def edit_connection():
                &#34;&#34;&#34;
                Permette di modificare la sicurezza delle connessioni dei Butlers.

                :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                &#34;&#34;&#34;
                return self.edit_butler(request)

        @self.flask.route(&#39;/standardModel&#39;, methods=[&#39;PUT&#39;])
        @self.auth.token_required
        def apply_standard_model():
                &#34;&#34;&#34;
                Permette di modificare la sicurezza delle connessioni dei Butlers.

                :return: una risposta vuota di successo, ritornata da un&#39;altra funzione.
                &#34;&#34;&#34;
                addr = self.get_json(request, &#39;addr&#39;, &#39;&#39;)
                editNum = self.callbacks[&#39;apply_standard_model&#39;](addr)
                returnData = {&#39;message&#39;: &#39;{} connessioni applicate a {}&#39;.format(editNum, addr)}
                return self.standard_response(returnData)

        &#34;&#34;&#34;
        ##########################################
        Fine funzioni aggiuntive butler-extensions
        ##########################################
        &#34;&#34;&#34;
        

        try:
                log.info(&#39;API di controllo avviata su {}:{}&#39;.format(self.ip, self.port))
                self.flask.run(host=self.ip, port=self.port, ssl_context=self.sslConf)
        except OSError as e:
                log.critical(&#39;Non è stato possibile avviare il centro di controllo su &#34;{}&#34;: {}&#39;.format(self.ip, e.__str__()))
                _exit(1)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.server" href="index.html">src.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.server.controlCenterAPI.ControlCenterAPI" href="#src.server.controlCenterAPI.ControlCenterAPI">ControlCenterAPI</a></code></h4>
<ul class="">
<li><code><a title="src.server.controlCenterAPI.ControlCenterAPI.edit_butler" href="#src.server.controlCenterAPI.ControlCenterAPI.edit_butler">edit_butler</a></code></li>
<li><code><a title="src.server.controlCenterAPI.ControlCenterAPI.start_api" href="#src.server.controlCenterAPI.ControlCenterAPI.start_api">start_api</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>